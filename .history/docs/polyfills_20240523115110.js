"use strict";(self.webpackChunkmy_test_app=self.webpackChunkmy_test_app||[]).push([[461],{4050:(Ze,$e,Re)=>{Re(4073),Re(6935),Re(542)},542:()=>{const Ze="\n",$e={},Re="__creationTrace__",Ke="STACKTRACE TRACKING",He="__SEP_TAG__";let Je=He+"@[native]";class Ge{constructor(){this.error=Ye(),this.timestamp=new Date}}function We(){return new Error(Ke)}function et(){try{throw We()}catch(u){return u}}const Ne=We(),Fe=et(),Ye=Ne.stack?We:Fe.stack?et:We;function tt(u){return u.stack?u.stack.split(Ze):[]}function st(u,r){let m=tt(r);for(let h=0;h<m.length;h++)$e.hasOwnProperty(m[h])||u.push(m[h])}function ie(u,r){const m=[r?r.trim():""];if(u){let h=(new Date).getTime();for(let y=0;y<u.length;y++){const _=u[y],A=_.timestamp;let T=`____________________Elapsed ${h-A.getTime()} ms; At: ${A}`;T=T.replace(/[^\w\d]/g,"_"),m.push(Je.replace(He,T)),st(m,_.error),h=A.getTime()}}return m.join(Ze)}function Ve(){return Error.stackTraceLimit>0}function Ue(u,r){r>0&&(u.push(tt((new Ge).error)),Ue(u,r-1))}Zone.longStackTraceZoneSpec={name:"long-stack-trace",longStackTraceLimit:10,getLongStackTrace:function(u){if(!u)return;const r=u[Zone.__symbol__("currentTaskTrace")];return r?ie(r,u.stack):u.stack},onScheduleTask:function(u,r,m,h){if(Ve()){const y=Zone.currentTask;let _=y&&y.data&&y.data[Re]||[];_=[new Ge].concat(_),_.length>this.longStackTraceLimit&&(_.length=this.longStackTraceLimit),h.data||(h.data={}),"eventTask"===h.type&&(h.data={...h.data}),h.data[Re]=_}return u.scheduleTask(m,h)},onHandleError:function(u,r,m,h){if(Ve()){const y=Zone.currentTask||h.task;if(h instanceof Error&&y){const _=ie(y.data&&y.data[Re],h.stack);try{h.stack=h.longStack=_}catch{}}}return u.handleError(m,h)}},function ke(){if(!Ve())return;const u=[];Ue(u,2);const r=u[0],m=u[1];for(let h=0;h<r.length;h++){const y=r[h];if(-1==y.indexOf(Ke)){let _=y.match(/^\s*at\s+/);if(_){Je=_[0]+He+" (http://localhost)";break}}}for(let h=0;h<r.length;h++){const y=r[h];if(y!==m[h])break;$e[y]=!0}}();class ze{static get(){return Zone.current.get("ProxyZoneSpec")}static isLoaded(){return ze.get()instanceof ze}static assertPresent(){if(!ze.isLoaded())throw new Error("Expected to be running in 'ProxyZone', but it was not found.");return ze.get()}constructor(r=null){this.defaultSpecDelegate=r,this.name="ProxyZone",this._delegateSpec=null,this.properties={ProxyZoneSpec:this},this.propertyKeys=null,this.lastTaskState=null,this.isNeedToTriggerHasTask=!1,this.tasks=[],this.setDelegate(r)}setDelegate(r){const m=this._delegateSpec!==r;this._delegateSpec=r,this.propertyKeys&&this.propertyKeys.forEach(h=>delete this.properties[h]),this.propertyKeys=null,r&&r.properties&&(this.propertyKeys=Object.keys(r.properties),this.propertyKeys.forEach(h=>this.properties[h]=r.properties[h])),m&&this.lastTaskState&&(this.lastTaskState.macroTask||this.lastTaskState.microTask)&&(this.isNeedToTriggerHasTask=!0)}getDelegate(){return this._delegateSpec}resetDelegate(){this.getDelegate(),this.setDelegate(this.defaultSpecDelegate)}tryTriggerHasTask(r,m,h){this.isNeedToTriggerHasTask&&this.lastTaskState&&(this.isNeedToTriggerHasTask=!1,this.onHasTask(r,m,h,this.lastTaskState))}removeFromTasks(r){if(this.tasks)for(let m=0;m<this.tasks.length;m++)if(this.tasks[m]===r)return void this.tasks.splice(m,1)}getAndClearPendingTasksInfo(){if(0===this.tasks.length)return"";const m="--Pending async tasks are: ["+this.tasks.map(h=>{const y=h.data&&Object.keys(h.data).map(_=>_+":"+h.data[_]).join(",");return`type: ${h.type}, source: ${h.source}, args: {${y}}`})+"]";return this.tasks=[],m}onFork(r,m,h,y){return this._delegateSpec&&this._delegateSpec.onFork?this._delegateSpec.onFork(r,m,h,y):r.fork(h,y)}onIntercept(r,m,h,y,_){return this._delegateSpec&&this._delegateSpec.onIntercept?this._delegateSpec.onIntercept(r,m,h,y,_):r.intercept(h,y,_)}onInvoke(r,m,h,y,_,A,T){return this.tryTriggerHasTask(r,m,h),this._delegateSpec&&this._delegateSpec.onInvoke?this._delegateSpec.onInvoke(r,m,h,y,_,A,T):r.invoke(h,y,_,A,T)}onHandleError(r,m,h,y){return this._delegateSpec&&this._delegateSpec.onHandleError?this._delegateSpec.onHandleError(r,m,h,y):r.handleError(h,y)}onScheduleTask(r,m,h,y){return"eventTask"!==y.type&&this.tasks.push(y),this._delegateSpec&&this._delegateSpec.onScheduleTask?this._delegateSpec.onScheduleTask(r,m,h,y):r.scheduleTask(h,y)}onInvokeTask(r,m,h,y,_,A){return"eventTask"!==y.type&&this.removeFromTasks(y),this.tryTriggerHasTask(r,m,h),this._delegateSpec&&this._delegateSpec.onInvokeTask?this._delegateSpec.onInvokeTask(r,m,h,y,_,A):r.invokeTask(h,y,_,A)}onCancelTask(r,m,h,y){return"eventTask"!==y.type&&this.removeFromTasks(y),this.tryTriggerHasTask(r,m,h),this._delegateSpec&&this._delegateSpec.onCancelTask?this._delegateSpec.onCancelTask(r,m,h,y):r.cancelTask(h,y)}onHasTask(r,m,h,y){this.lastTaskState=y,this._delegateSpec&&this._delegateSpec.onHasTask?this._delegateSpec.onHasTask(r,m,h,y):r.hasTask(h,y)}}Zone.ProxyZoneSpec=ze,Zone.SyncTestZoneSpec=class nt{constructor(r){this.runZone=Zone.current,this.name="syncTestZone for "+r}onScheduleTask(r,m,h,y){switch(y.type){case"microTask":case"macroTask":throw new Error(`Cannot call ${y.source} from within a sync test (${this.name}).`);case"eventTask":y=r.scheduleTask(h,y)}return y}},Zone.__load_patch("jasmine",(u,r,m)=>{if(!r)throw new Error("Missing: zone.js");if(typeof jest<"u"||typeof jasmine>"u"||jasmine.__zone_patch__)return;jasmine.__zone_patch__=!0;const y=r.SyncTestZoneSpec,_=r.ProxyZoneSpec;if(!y)throw new Error("Missing: SyncTestZoneSpec");if(!_)throw new Error("Missing: ProxyZoneSpec");const A=r.current,T=r.__symbol__,w=!0===u[T("fakeAsyncDisablePatchingClock")],E=!w&&(!0===u[T("fakeAsyncPatchLock")]||!0===u[T("fakeAsyncAutoFakeAsyncWhenClockPatched")]);if(!0!==u[T("ignoreUnhandledRejection")]){const D=jasmine.GlobalErrors;D&&!jasmine[T("GlobalErrors")]&&(jasmine[T("GlobalErrors")]=D,jasmine.GlobalErrors=function(){const C=new D,g=C.install;return g&&!C[T("install")]&&(C[T("install")]=g,C.install=function(){const Z=typeof process<"u"&&!!process.on,z=Z?process.listeners("unhandledRejection"):u.eventListeners("unhandledrejection"),$=g.apply(this,arguments);return Z?process.removeAllListeners("unhandledRejection"):u.removeAllListeners("unhandledrejection"),z&&z.forEach(Pe=>{Z?process.on("unhandledRejection",Pe):u.addEventListener("unhandledrejection",Pe)}),$}),C})}const j=jasmine.getEnv();if(["describe","xdescribe","fdescribe"].forEach(D=>{let C=j[D];j[D]=function(g,Z){return C.call(this,g,function W(D,C){return function(){return A.fork(new y(`jasmine.describe#${D}`)).run(C,this,arguments)}}(g,Z))}}),["it","xit","fit"].forEach(D=>{let C=j[D];j[T(D)]=C,j[D]=function(g,Z,z){return arguments[1]=P(Z),C.apply(this,arguments)}}),["beforeEach","afterEach","beforeAll","afterAll"].forEach(D=>{let C=j[D];j[T(D)]=C,j[D]=function(g,Z){return arguments[0]=P(g),C.apply(this,arguments)}}),!w){const D=jasmine[T("clock")]=jasmine.clock;jasmine.clock=function(){const C=D.apply(this,arguments);if(!C[T("patched")]){C[T("patched")]=T("patched");const g=C[T("tick")]=C.tick;C.tick=function(){const z=r.current.get("FakeAsyncTestZoneSpec");return z?z.tick.apply(z,arguments):g.apply(this,arguments)};const Z=C[T("mockDate")]=C.mockDate;C.mockDate=function(){const z=r.current.get("FakeAsyncTestZoneSpec");if(z){const $=arguments.length>0?arguments[0]:new Date;return z.setFakeBaseSystemTime.apply(z,$&&"function"==typeof $.getTime?[$.getTime()]:arguments)}return Z.apply(this,arguments)},E&&["install","uninstall"].forEach(z=>{const $=C[T(z)]=C[z];C[z]=function(){if(!r.FakeAsyncTestZoneSpec)return $.apply(this,arguments);jasmine[T("clockInstalled")]="install"===z}})}return C}}if(!jasmine[r.__symbol__("createSpyObj")]){const D=jasmine.createSpyObj;jasmine[r.__symbol__("createSpyObj")]=D,jasmine.createSpyObj=function(){const C=Array.prototype.slice.call(arguments);let Z;if(C.length>=3&&C[2]){const z=Object.defineProperty;Object.defineProperty=function($,Pe,qe){return z.call(this,$,Pe,{...qe,configurable:!0,enumerable:!0})};try{Z=D.apply(this,C)}finally{Object.defineProperty=z}}else Z=D.apply(this,C);return Z}}function b(D,C,g,Z){const z=!!jasmine[T("clockInstalled")],$=g.testProxyZone;if(z&&E){const Pe=r[r.__symbol__("fakeAsyncTest")];Pe&&"function"==typeof Pe.fakeAsync&&(D=Pe.fakeAsync(D))}return Z?$.run(D,C,[Z]):$.run(D,C)}function P(D){return D&&(D.length?function(C){return b(D,this,this.queueRunner,C)}:function(){return b(D,this,this.queueRunner)})}const U=jasmine.QueueRunner;jasmine.QueueRunner=function(D){function C(g){g.onComplete&&(g.onComplete=(Pe=>()=>{this.testProxyZone=null,this.testProxyZoneSpec=null,A.scheduleMicroTask("jasmine.onComplete",Pe)})(g.onComplete));const Z=u[r.__symbol__("setTimeout")],z=u[r.__symbol__("clearTimeout")];Z&&(g.timeout={setTimeout:Z||u.setTimeout,clearTimeout:z||u.clearTimeout}),jasmine.UserContext?(g.userContext||(g.userContext=new jasmine.UserContext),g.userContext.queueRunner=this):(g.userContext||(g.userContext={}),g.userContext.queueRunner=this);const $=g.onException;g.onException=function(Pe){if(Pe&&"Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL."===Pe.message){const qe=this&&this.testProxyZoneSpec;if(qe){const ct=qe.getAndClearPendingTasksInfo();try{Pe.message+=ct}catch{}}}$&&$.call(this,Pe)},D.call(this,g)}return function(D,C){for(const Z in C)C.hasOwnProperty(Z)&&(D[Z]=C[Z]);function g(){this.constructor=D}D.prototype=null===C?Object.create(C):(g.prototype=C.prototype,new g)}(C,D),C.prototype.execute=function(){let g=r.current,Z=!1;for(;g;){if(g===A){Z=!0;break}g=g.parent}if(!Z)throw new Error("Unexpected Zone: "+r.current.name);this.testProxyZoneSpec=new _,this.testProxyZone=A.fork(this.testProxyZoneSpec),r.currentTask?D.prototype.execute.call(this):r.current.scheduleMicroTask("jasmine.execute().forceTask",()=>U.prototype.execute.call(this))},C}(U)}),Zone.__load_patch("jest",(u,r,m)=>{if(typeof jest>"u"||jest.__zone_patch__)return;r[m.symbol("ignoreConsoleErrorUncaughtError")]=!0,jest.__zone_patch__=!0;const h=r.ProxyZoneSpec,y=r.SyncTestZoneSpec;if(!h)throw new Error("Missing ProxyZoneSpec");const _=r.current,A=_.fork(new y("jest.describe")),T=new h,w=_.fork(T);function j(b){return function(...P){return A.run(b,this,P)}}function W(b,P=!1){if("function"!=typeof b)return b;const U=function(){if(!0===r[m.symbol("useFakeTimersCalled")]&&b&&!b.isFakeAsync){const D=r[r.__symbol__("fakeAsyncTest")];D&&"function"==typeof D.fakeAsync&&(b=D.fakeAsync(b))}return T.isTestFunc=P,w.run(b,null,arguments)};return Object.defineProperty(U,"length",{configurable:!0,writable:!0,enumerable:!1}),U.length=b.length,U}["describe","xdescribe","fdescribe"].forEach(b=>{let P=u[b];u[r.__symbol__(b)]||(u[r.__symbol__(b)]=P,u[b]=function(...U){return U[1]=j(U[1]),P.apply(this,U)},u[b].each=function E(b){return function(...P){const U=b.apply(this,P);return function(...D){return D[1]=j(D[1]),U.apply(this,D)}}}(P.each))}),u.describe.only=u.fdescribe,u.describe.skip=u.xdescribe,["it","xit","fit","test","xtest"].forEach(b=>{let P=u[b];u[r.__symbol__(b)]||(u[r.__symbol__(b)]=P,u[b]=function(...U){return U[1]=W(U[1],!0),P.apply(this,U)},u[b].each=function d(b){return function(...P){return function(...U){return U[1]=W(U[1]),b.apply(this,P).apply(this,U)}}}(P.each),u[b].todo=P.todo)}),u.it.only=u.fit,u.it.skip=u.xit,u.test.only=u.fit,u.test.skip=u.xit,["beforeEach","afterEach","beforeAll","afterAll"].forEach(b=>{let P=u[b];u[r.__symbol__(b)]||(u[r.__symbol__(b)]=P,u[b]=function(...U){return U[0]=W(U[0]),P.apply(this,U)})}),r.patchJestObject=function(P,U=!1){function D(){return!!r.current.get("FakeAsyncTestZoneSpec")}function C(){const g=r.current.get("ProxyZoneSpec");return g&&g.isTestFunc}P[m.symbol("fakeTimers")]||(P[m.symbol("fakeTimers")]=!0,m.patchMethod(P,"_checkFakeTimers",g=>function(Z,z){return!!D()||g.apply(Z,z)}),m.patchMethod(P,"useFakeTimers",g=>function(Z,z){return r[m.symbol("useFakeTimersCalled")]=!0,U||C()?g.apply(Z,z):Z}),m.patchMethod(P,"useRealTimers",g=>function(Z,z){return r[m.symbol("useFakeTimersCalled")]=!1,U||C()?g.apply(Z,z):Z}),m.patchMethod(P,"setSystemTime",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$||!D())return g.apply(Z,z);$.setFakeBaseSystemTime(z[0])}),m.patchMethod(P,"getRealSystemTime",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");return $&&D()?$.getRealSystemTime():g.apply(Z,z)}),m.patchMethod(P,"runAllTicks",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$)return g.apply(Z,z);$.flushMicrotasks()}),m.patchMethod(P,"runAllTimers",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$)return g.apply(Z,z);$.flush(100,!0)}),m.patchMethod(P,"advanceTimersByTime",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$)return g.apply(Z,z);$.tick(z[0])}),m.patchMethod(P,"runOnlyPendingTimers",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$)return g.apply(Z,z);$.flushOnlyPendingTimers()}),m.patchMethod(P,"advanceTimersToNextTimer",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$)return g.apply(Z,z);$.tickToNext(z[0])}),m.patchMethod(P,"clearAllTimers",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");if(!$)return g.apply(Z,z);$.removeAllTimers()}),m.patchMethod(P,"getTimerCount",g=>function(Z,z){const $=r.current.get("FakeAsyncTestZoneSpec");return $?$.getTimerCount():g.apply(Z,z)}))}}),Zone.__load_patch("mocha",(u,r)=>{const m=u.Mocha;if(typeof m>"u")return;if(typeof r>"u")throw new Error("Missing Zone.js");const h=r.ProxyZoneSpec,y=r.SyncTestZoneSpec;if(!h)throw new Error("Missing ProxyZoneSpec");if(m.__zone_patch__)throw new Error('"Mocha" has already been patched with "Zone".');m.__zone_patch__=!0;const _=r.current,A=_.fork(new y("Mocha.describe"));let T=null;const w=_.fork(new h),E={after:u.after,afterEach:u.afterEach,before:u.before,beforeEach:u.beforeEach,describe:u.describe,it:u.it};function d(P,U,D){for(let C=0;C<P.length;C++){let g=P[C];"function"==typeof g&&(P[C]=0===g.length?U(g):D(g),P[C].toString=function(){return g.toString()})}return P}function j(P){return d(P,function(D){return function(){return A.run(D,this,arguments)}})}function W(P){return d(P,function(C){return function(){return T.run(C,this)}},function(C){return function(g){return T.run(C,this,[g])}})}function b(P){return d(P,function(C){return function(){return w.run(C,this)}},function(C){return function(g){return w.run(C,this,[g])}})}var P,U;u.describe=u.suite=function(){return E.describe.apply(this,j(arguments))},u.xdescribe=u.suite.skip=u.describe.skip=function(){return E.describe.skip.apply(this,j(arguments))},u.describe.only=u.suite.only=function(){return E.describe.only.apply(this,j(arguments))},u.it=u.specify=u.test=function(){return E.it.apply(this,W(arguments))},u.xit=u.xspecify=u.it.skip=function(){return E.it.skip.apply(this,W(arguments))},u.it.only=u.test.only=function(){return E.it.only.apply(this,W(arguments))},u.after=u.suiteTeardown=function(){return E.after.apply(this,b(arguments))},u.afterEach=u.teardown=function(){return E.afterEach.apply(this,W(arguments))},u.before=u.suiteSetup=function(){return E.before.apply(this,b(arguments))},u.beforeEach=u.setup=function(){return E.beforeEach.apply(this,W(arguments))},P=m.Runner.prototype.runTest,U=m.Runner.prototype.run,m.Runner.prototype.runTest=function(D){r.current.scheduleMicroTask("mocha.forceTask",()=>{P.call(this,D)})},m.Runner.prototype.run=function(D){return this.on("test",C=>{T=_.fork(new h)}),this.on("fail",(C,g)=>{const Z=T&&T.get("ProxyZoneSpec");if(Z&&g)try{g.message+=Z.getAndClearPendingTasksInfo()}catch{}}),U.call(this,D)}}),function(u){class r{static#e=this.symbolParentUnresolved=Zone.__symbol__("parentUnresolved");constructor(h,y,_){this.finishCallback=h,this.failCallback=y,this._pendingMicroTasks=!1,this._pendingMacroTasks=!1,this._alreadyErrored=!1,this._isSync=!1,this._existingFinishTimer=null,this.entryFunction=null,this.runZone=Zone.current,this.unresolvedChainedPromiseCount=0,this.supportWaitUnresolvedChainedPromise=!1,this.name="asyncTestZone for "+_,this.properties={AsyncTestZoneSpec:this},this.supportWaitUnresolvedChainedPromise=!0===u[Zone.__symbol__("supportWaitUnResolvedChainedPromise")]}isUnresolvedChainedPromisePending(){return this.unresolvedChainedPromiseCount>0}_finishCallbackIfDone(){null!==this._existingFinishTimer&&(clearTimeout(this._existingFinishTimer),this._existingFinishTimer=null),this._pendingMicroTasks||this._pendingMacroTasks||this.supportWaitUnresolvedChainedPromise&&this.isUnresolvedChainedPromisePending()||this.runZone.run(()=>{this._existingFinishTimer=setTimeout(()=>{!this._alreadyErrored&&!this._pendingMicroTasks&&!this._pendingMacroTasks&&this.finishCallback()},0)})}patchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const h=Promise[Zone.__symbol__("patchPromiseForTest")];h&&h()}unPatchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const h=Promise[Zone.__symbol__("unPatchPromiseForTest")];h&&h()}onScheduleTask(h,y,_,A){return"eventTask"!==A.type&&(this._isSync=!1),"microTask"===A.type&&A.data&&A.data instanceof Promise&&!0===A.data[r.symbolParentUnresolved]&&this.unresolvedChainedPromiseCount--,h.scheduleTask(_,A)}onInvokeTask(h,y,_,A,T,w){return"eventTask"!==A.type&&(this._isSync=!1),h.invokeTask(_,A,T,w)}onCancelTask(h,y,_,A){return"eventTask"!==A.type&&(this._isSync=!1),h.cancelTask(_,A)}onInvoke(h,y,_,A,T,w,E){this.entryFunction||(this.entryFunction=A);try{return this._isSync=!0,h.invoke(_,A,T,w,E)}finally{this._isSync&&this.entryFunction===A&&this._finishCallbackIfDone()}}onHandleError(h,y,_,A){return h.handleError(_,A)&&(this.failCallback(A),this._alreadyErrored=!0),!1}onHasTask(h,y,_,A){h.hasTask(_,A),y===_&&("microTask"==A.change?(this._pendingMicroTasks=A.microTask,this._finishCallbackIfDone()):"macroTask"==A.change&&(this._pendingMacroTasks=A.macroTask,this._finishCallbackIfDone()))}}Zone.AsyncTestZoneSpec=r}(typeof window<"u"&&window||typeof self<"u"&&self||global),Zone.__load_patch("asynctest",(u,r,m)=>{function h(y,_,A,T){const w=r.current,E=r.AsyncTestZoneSpec;if(void 0===E)throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/async-test");const d=r.ProxyZoneSpec;if(!d)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");const j=d.get();d.assertPresent();const W=r.current.getZoneWith("ProxyZoneSpec"),b=j.getDelegate();return W.parent.run(()=>{const P=new E(()=>{j.getDelegate()==P&&j.setDelegate(b),P.unPatchPromiseForTest(),w.run(()=>{A()})},U=>{j.getDelegate()==P&&j.setDelegate(b),P.unPatchPromiseForTest(),w.run(()=>{T(U)})},"test");j.setDelegate(P),P.patchPromiseForTest()}),r.current.runGuarded(y,_)}r[m.symbol("asyncTest")]=function(_){return u.jasmine?function(A){A||((A=function(){}).fail=function(T){throw T}),h(_,this,A,T=>{if("string"==typeof T)return A.fail(new Error(T));A.fail(T)})}:function(){return new Promise((A,T)=>{h(_,this,A,T)})}}}),function(u){const r=u.Date;function m(){if(0===arguments.length){const A=new r;return A.setTime(m.now()),A}{const A=Array.prototype.slice.call(arguments);return new r(...A)}}m.now=function(){const A=Zone.current.get("FakeAsyncTestZoneSpec");return A?A.getFakeSystemTime():r.now.apply(this,arguments)},m.UTC=r.UTC,m.parse=r.parse;const h={setTimeout:u.setTimeout,setInterval:u.setInterval,clearTimeout:u.clearTimeout,clearInterval:u.clearInterval};let y=(()=>{class A{static#e=this.nextId=1;constructor(){this._schedulerQueue=[],this._currentTickTime=0,this._currentFakeBaseSystemTime=r.now(),this._currentTickRequeuePeriodicEntries=[]}getCurrentTickTime(){return this._currentTickTime}getFakeSystemTime(){return this._currentFakeBaseSystemTime+this._currentTickTime}setFakeBaseSystemTime(w){this._currentFakeBaseSystemTime=w}getRealSystemTime(){return r.now()}scheduleFunction(w,E,d){let j=(d={args:[],isPeriodic:!1,isRequestAnimationFrame:!1,id:-1,isRequeuePeriodic:!1,...d}).id<0?A.nextId++:d.id,b={endTime:this._currentTickTime+E,id:j,func:w,args:d.args,delay:E,isPeriodic:d.isPeriodic,isRequestAnimationFrame:d.isRequestAnimationFrame};d.isRequeuePeriodic&&this._currentTickRequeuePeriodicEntries.push(b);let P=0;for(;P<this._schedulerQueue.length&&!(b.endTime<this._schedulerQueue[P].endTime);P++);return this._schedulerQueue.splice(P,0,b),j}removeScheduledFunctionWithId(w){for(let E=0;E<this._schedulerQueue.length;E++)if(this._schedulerQueue[E].id==w){this._schedulerQueue.splice(E,1);break}}removeAll(){this._schedulerQueue=[]}getTimerCount(){return this._schedulerQueue.length}tickToNext(w=1,E,d){this._schedulerQueue.length<w||this.tick(this._schedulerQueue[w-1].endTime-this._currentTickTime,E,d)}tick(w=0,E,d){let j=this._currentTickTime+w,W=0;const b=(d=Object.assign({processNewMacroTasksSynchronously:!0},d)).processNewMacroTasksSynchronously?this._schedulerQueue:this._schedulerQueue.slice();if(0===b.length&&E)E(w);else{for(;b.length>0&&(this._currentTickRequeuePeriodicEntries=[],!(j<b[0].endTime));){let U=b.shift();if(!d.processNewMacroTasksSynchronously){const C=this._schedulerQueue.indexOf(U);C>=0&&this._schedulerQueue.splice(C,1)}if(W=this._currentTickTime,this._currentTickTime=U.endTime,E&&E(this._currentTickTime-W),!U.func.apply(u,U.isRequestAnimationFrame?[this._currentTickTime]:U.args))break;d.processNewMacroTasksSynchronously||this._currentTickRequeuePeriodicEntries.forEach(C=>{let g=0;for(;g<b.length&&!(C.endTime<b[g].endTime);g++);b.splice(g,0,C)})}W=this._currentTickTime,this._currentTickTime=j,E&&E(this._currentTickTime-W)}}flushOnlyPendingTimers(w){if(0===this._schedulerQueue.length)return 0;const E=this._currentTickTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-E,w,{processNewMacroTasksSynchronously:!1}),this._currentTickTime-E}flush(w=20,E=!1,d){return E?this.flushPeriodic(d):this.flushNonPeriodic(w,d)}flushPeriodic(w){if(0===this._schedulerQueue.length)return 0;const E=this._currentTickTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-E,w),this._currentTickTime-E}flushNonPeriodic(w,E){const d=this._currentTickTime;let j=0,W=0;for(;this._schedulerQueue.length>0;){if(W++,W>w)throw new Error("flush failed after reaching the limit of "+w+" tasks. Does your code use a polling timeout?");if(0===this._schedulerQueue.filter(U=>!U.isPeriodic&&!U.isRequestAnimationFrame).length)break;const b=this._schedulerQueue.shift();if(j=this._currentTickTime,this._currentTickTime=b.endTime,E&&E(this._currentTickTime-j),!b.func.apply(u,b.args))break}return this._currentTickTime-d}}return A})();class _{static assertInZone(){if(null==Zone.current.get("FakeAsyncTestZoneSpec"))throw new Error("The code should be running in the fakeAsync zone to call this function")}constructor(T,w=!1,E){this.trackPendingRequestAnimationFrame=w,this.macroTaskOptions=E,this._scheduler=new y,this._microtasks=[],this._lastError=null,this._uncaughtPromiseErrors=Promise[Zone.__symbol__("uncaughtPromiseErrors")],this.pendingPeriodicTimers=[],this.pendingTimers=[],this.patchDateLocked=!1,this.properties={FakeAsyncTestZoneSpec:this},this.name="fakeAsyncTestZone for "+T,this.macroTaskOptions||(this.macroTaskOptions=u[Zone.__symbol__("FakeAsyncTestMacroTask")])}_fnAndFlush(T,w){return(...E)=>(T.apply(u,E),null===this._lastError?(null!=w.onSuccess&&w.onSuccess.apply(u),this.flushMicrotasks()):null!=w.onError&&w.onError.apply(u),null===this._lastError)}static _removeTimer(T,w){let E=T.indexOf(w);E>-1&&T.splice(E,1)}_dequeueTimer(T){return()=>{_._removeTimer(this.pendingTimers,T)}}_requeuePeriodicTimer(T,w,E,d){return()=>{-1!==this.pendingPeriodicTimers.indexOf(d)&&this._scheduler.scheduleFunction(T,w,{args:E,isPeriodic:!0,id:d,isRequeuePeriodic:!0})}}_dequeuePeriodicTimer(T){return()=>{_._removeTimer(this.pendingPeriodicTimers,T)}}_setTimeout(T,w,E,d=!0){let j=this._dequeueTimer(y.nextId),W=this._fnAndFlush(T,{onSuccess:j,onError:j}),b=this._scheduler.scheduleFunction(W,w,{args:E,isRequestAnimationFrame:!d});return d&&this.pendingTimers.push(b),b}_clearTimeout(T){_._removeTimer(this.pendingTimers,T),this._scheduler.removeScheduledFunctionWithId(T)}_setInterval(T,w,E){let d=y.nextId,j={onSuccess:null,onError:this._dequeuePeriodicTimer(d)},W=this._fnAndFlush(T,j);return j.onSuccess=this._requeuePeriodicTimer(W,w,E,d),this._scheduler.scheduleFunction(W,w,{args:E,isPeriodic:!0}),this.pendingPeriodicTimers.push(d),d}_clearInterval(T){_._removeTimer(this.pendingPeriodicTimers,T),this._scheduler.removeScheduledFunctionWithId(T)}_resetLastErrorAndThrow(){let T=this._lastError||this._uncaughtPromiseErrors[0];throw this._uncaughtPromiseErrors.length=0,this._lastError=null,T}getCurrentTickTime(){return this._scheduler.getCurrentTickTime()}getFakeSystemTime(){return this._scheduler.getFakeSystemTime()}setFakeBaseSystemTime(T){this._scheduler.setFakeBaseSystemTime(T)}getRealSystemTime(){return this._scheduler.getRealSystemTime()}static patchDate(){u[Zone.__symbol__("disableDatePatching")]||u.Date!==m&&(u.Date=m,m.prototype=r.prototype,_.checkTimerPatch())}static resetDate(){u.Date===m&&(u.Date=r)}static checkTimerPatch(){u.setTimeout!==h.setTimeout&&(u.setTimeout=h.setTimeout,u.clearTimeout=h.clearTimeout),u.setInterval!==h.setInterval&&(u.setInterval=h.setInterval,u.clearInterval=h.clearInterval)}lockDatePatch(){this.patchDateLocked=!0,_.patchDate()}unlockDatePatch(){this.patchDateLocked=!1,_.resetDate()}tickToNext(T=1,w,E={processNewMacroTasksSynchronously:!0}){T<=0||(_.assertInZone(),this.flushMicrotasks(),this._scheduler.tickToNext(T,w,E),null!==this._lastError&&this._resetLastErrorAndThrow())}tick(T=0,w,E={processNewMacroTasksSynchronously:!0}){_.assertInZone(),this.flushMicrotasks(),this._scheduler.tick(T,w,E),null!==this._lastError&&this._resetLastErrorAndThrow()}flushMicrotasks(){for(_.assertInZone();this._microtasks.length>0;){let w=this._microtasks.shift();w.func.apply(w.target,w.args)}(()=>{(null!==this._lastError||this._uncaughtPromiseErrors.length)&&this._resetLastErrorAndThrow()})()}flush(T,w,E){_.assertInZone(),this.flushMicrotasks();const d=this._scheduler.flush(T,w,E);return null!==this._lastError&&this._resetLastErrorAndThrow(),d}flushOnlyPendingTimers(T){_.assertInZone(),this.flushMicrotasks();const w=this._scheduler.flushOnlyPendingTimers(T);return null!==this._lastError&&this._resetLastErrorAndThrow(),w}removeAllTimers(){_.assertInZone(),this._scheduler.removeAll(),this.pendingPeriodicTimers=[],this.pendingTimers=[]}getTimerCount(){return this._scheduler.getTimerCount()+this._microtasks.length}onScheduleTask(T,w,E,d){switch(d.type){case"microTask":let W,j=d.data&&d.data.args;if(j){let b=d.data.cbIdx;"number"==typeof j.length&&j.length>b+1&&(W=Array.prototype.slice.call(j,b+1))}this._microtasks.push({func:d.invoke,args:W,target:d.data&&d.data.target});break;case"macroTask":switch(d.source){case"setTimeout":d.data.handleId=this._setTimeout(d.invoke,d.data.delay,Array.prototype.slice.call(d.data.args,2));break;case"setImmediate":d.data.handleId=this._setTimeout(d.invoke,0,Array.prototype.slice.call(d.data.args,1));break;case"setInterval":d.data.handleId=this._setInterval(d.invoke,d.data.delay,Array.prototype.slice.call(d.data.args,2));break;case"XMLHttpRequest.send":throw new Error("Cannot make XHRs from within a fake async test. Request URL: "+d.data.url);case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":d.data.handleId=this._setTimeout(d.invoke,16,d.data.args,this.trackPendingRequestAnimationFrame);break;default:const b=this.findMacroTaskOption(d);if(b){const P=d.data&&d.data.args,U=P&&P.length>1?P[1]:0;let D=b.callbackArgs?b.callbackArgs:P;b.isPeriodic?(d.data.handleId=this._setInterval(d.invoke,U,D),d.data.isPeriodic=!0):d.data.handleId=this._setTimeout(d.invoke,U,D);break}throw new Error("Unknown macroTask scheduled in fake async test: "+d.source)}break;case"eventTask":d=T.scheduleTask(E,d)}return d}onCancelTask(T,w,E,d){switch(d.source){case"setTimeout":case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":return this._clearTimeout(d.data.handleId);case"setInterval":return this._clearInterval(d.data.handleId);default:const j=this.findMacroTaskOption(d);if(j){const W=d.data.handleId;return j.isPeriodic?this._clearInterval(W):this._clearTimeout(W)}return T.cancelTask(E,d)}}onInvoke(T,w,E,d,j,W,b){try{return _.patchDate(),T.invoke(E,d,j,W,b)}finally{this.patchDateLocked||_.resetDate()}}findMacroTaskOption(T){if(!this.macroTaskOptions)return null;for(let w=0;w<this.macroTaskOptions.length;w++){const E=this.macroTaskOptions[w];if(E.source===T.source)return E}return null}onHandleError(T,w,E,d){return this._lastError=d,!1}}Zone.FakeAsyncTestZoneSpec=_}("object"==typeof window&&window||"object"==typeof self&&self||global),Zone.__load_patch("fakeasync",(u,r,m)=>{const h=r&&r.FakeAsyncTestZoneSpec;function y(){return r&&r.ProxyZoneSpec}let _=null;function A(){_&&_.unlockDatePatch(),_=null,y()&&y().assertPresent().resetDelegate()}function w(){if(null==_&&(_=r.current.get("FakeAsyncTestZoneSpec"),null==_))throw new Error("The code should be running in the fakeAsync zone to call this function");return _}function W(){w().flushMicrotasks()}r[m.symbol("fakeAsyncTest")]={resetFakeAsyncZone:A,flushMicrotasks:W,discardPeriodicTasks:function j(){w().pendingPeriodicTimers.length=0},tick:function E(b=0,P=!1){w().tick(b,null,P)},flush:function d(b){return w().flush(b)},fakeAsync:function T(b){const P=function(...U){const D=y();if(!D)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");const C=D.assertPresent();if(r.current.get("FakeAsyncTestZoneSpec"))throw new Error("fakeAsync() calls can not be nested");try{if(!_){if(C.getDelegate()instanceof h)throw new Error("fakeAsync() calls can not be nested");_=new h}let g;const Z=C.getDelegate();C.setDelegate(_),_.lockDatePatch();try{g=b.apply(this,U),W()}finally{C.setDelegate(Z)}if(_.pendingPeriodicTimers.length>0)throw new Error(`${_.pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);if(_.pendingTimers.length>0)throw new Error(`${_.pendingTimers.length} timer(s) still in the queue.`);return g}finally{A()}};return P.isFakeAsync=!0,P}}},!0),Zone.__load_patch("promisefortest",(u,r,m)=>{const h=m.symbol("state"),_=m.symbol("parentUnresolved");Promise[m.symbol("patchPromiseForTest")]=function(){let T=Promise[r.__symbol__("ZonePromiseThen")];T||(T=Promise[r.__symbol__("ZonePromiseThen")]=Promise.prototype.then,Promise.prototype.then=function(){const w=T.apply(this,arguments);if(null===this[h]){const E=r.current.get("AsyncTestZoneSpec");E&&(E.unresolvedChainedPromiseCount++,w[_]=!0)}return w})},Promise[m.symbol("unPatchPromiseForTest")]=function(){const T=Promise[r.__symbol__("ZonePromiseThen")];T&&(Promise.prototype.then=T,Promise[r.__symbol__("ZonePromiseThen")]=void 0)}})},6935:()=>{!function(e){const n=e.performance;function o(le){n&&n.mark&&n.mark(le)}function a(le,H){n&&n.measure&&n.measure(le,H)}o("Zone");const f=e.__Zone_symbol_prefix||"__zone_symbol__";function k(le){return f+le}const x=!0===e[k("forceDuplicateZoneCheck")];if(e.Zone){if(x||"function"!=typeof e.Zone.__symbol__)throw new Error("Zone already loaded.");return e.Zone}let N=(()=>{class le{static#e=this.__symbol__=k;static assertZonePatched(){if(e.Promise!==Qe.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let t=le.current;for(;t.parent;)t=t.parent;return t}static get current(){return Ee.zone}static get currentTask(){return Be}static __load_patch(t,i,Q=!1){if(Qe.hasOwnProperty(t)){if(!Q&&x)throw Error("Already loaded patch: "+t)}else if(!e["__Zone_disable_"+t]){const te="Zone:"+t;o(te),Qe[t]=i(e,le,Ie),a(te,te)}}get parent(){return this._parent}get name(){return this._name}constructor(t,i){this._parent=t,this._name=i?i.name||"unnamed":"<root>",this._properties=i&&i.properties||{},this._zoneDelegate=new X(this,this._parent&&this._parent._zoneDelegate,i)}get(t){const i=this.getZoneWith(t);if(i)return i._properties[t]}getZoneWith(t){let i=this;for(;i;){if(i._properties.hasOwnProperty(t))return i;i=i._parent}return null}fork(t){if(!t)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,t)}wrap(t,i){if("function"!=typeof t)throw new Error("Expecting function got: "+t);const Q=this._zoneDelegate.intercept(this,t,i),te=this;return function(){return te.runGuarded(Q,this,arguments,i)}}run(t,i,Q,te){Ee={parent:Ee,zone:this};try{return this._zoneDelegate.invoke(this,t,i,Q,te)}finally{Ee=Ee.parent}}runGuarded(t,i=null,Q,te){Ee={parent:Ee,zone:this};try{try{return this._zoneDelegate.invoke(this,t,i,Q,te)}catch(Ae){if(this._zoneDelegate.handleError(this,Ae))throw Ae}}finally{Ee=Ee.parent}}runTask(t,i,Q){if(t.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(t.zone||De).name+"; Execution: "+this.name+")");if(t.state===de&&(t.type===Me||t.type===Y))return;const te=t.state!=L;te&&t._transitionTo(L,he),t.runCount++;const Ae=Be;Be=t,Ee={parent:Ee,zone:this};try{t.type==Y&&t.data&&!t.data.isPeriodic&&(t.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,t,i,Q)}catch(I){if(this._zoneDelegate.handleError(this,I))throw I}}finally{t.state!==de&&t.state!==O&&(t.type==Me||t.data&&t.data.isPeriodic?te&&t._transitionTo(he,L):(t.runCount=0,this._updateTaskCount(t,-1),te&&t._transitionTo(de,L,de))),Ee=Ee.parent,Be=Ae}}scheduleTask(t){if(t.zone&&t.zone!==this){let Q=this;for(;Q;){if(Q===t.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`);Q=Q.parent}}t._transitionTo(be,de);const i=[];t._zoneDelegates=i,t._zone=this;try{t=this._zoneDelegate.scheduleTask(this,t)}catch(Q){throw t._transitionTo(O,be,de),this._zoneDelegate.handleError(this,Q),Q}return t._zoneDelegates===i&&this._updateTaskCount(t,1),t.state==be&&t._transitionTo(he,be),t}scheduleMicroTask(t,i,Q,te){return this.scheduleTask(new q(ae,t,i,Q,te,void 0))}scheduleMacroTask(t,i,Q,te,Ae){return this.scheduleTask(new q(Y,t,i,Q,te,Ae))}scheduleEventTask(t,i,Q,te,Ae){return this.scheduleTask(new q(Me,t,i,Q,te,Ae))}cancelTask(t){if(t.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(t.zone||De).name+"; Execution: "+this.name+")");if(t.state===he||t.state===L){t._transitionTo(pe,he,L);try{this._zoneDelegate.cancelTask(this,t)}catch(i){throw t._transitionTo(O,pe),this._zoneDelegate.handleError(this,i),i}return this._updateTaskCount(t,-1),t._transitionTo(de,pe),t.runCount=0,t}}_updateTaskCount(t,i){const Q=t._zoneDelegates;-1==i&&(t._zoneDelegates=null);for(let te=0;te<Q.length;te++)Q[te]._updateTaskCount(t.type,i)}}return le})();const K={name:"",onHasTask:(le,H,t,i)=>le.hasTask(t,i),onScheduleTask:(le,H,t,i)=>le.scheduleTask(t,i),onInvokeTask:(le,H,t,i,Q,te)=>le.invokeTask(t,i,Q,te),onCancelTask:(le,H,t,i)=>le.cancelTask(t,i)};class X{constructor(H,t,i){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=H,this._parentDelegate=t,this._forkZS=i&&(i&&i.onFork?i:t._forkZS),this._forkDlgt=i&&(i.onFork?t:t._forkDlgt),this._forkCurrZone=i&&(i.onFork?this.zone:t._forkCurrZone),this._interceptZS=i&&(i.onIntercept?i:t._interceptZS),this._interceptDlgt=i&&(i.onIntercept?t:t._interceptDlgt),this._interceptCurrZone=i&&(i.onIntercept?this.zone:t._interceptCurrZone),this._invokeZS=i&&(i.onInvoke?i:t._invokeZS),this._invokeDlgt=i&&(i.onInvoke?t:t._invokeDlgt),this._invokeCurrZone=i&&(i.onInvoke?this.zone:t._invokeCurrZone),this._handleErrorZS=i&&(i.onHandleError?i:t._handleErrorZS),this._handleErrorDlgt=i&&(i.onHandleError?t:t._handleErrorDlgt),this._handleErrorCurrZone=i&&(i.onHandleError?this.zone:t._handleErrorCurrZone),this._scheduleTaskZS=i&&(i.onScheduleTask?i:t._scheduleTaskZS),this._scheduleTaskDlgt=i&&(i.onScheduleTask?t:t._scheduleTaskDlgt),this._scheduleTaskCurrZone=i&&(i.onScheduleTask?this.zone:t._scheduleTaskCurrZone),this._invokeTaskZS=i&&(i.onInvokeTask?i:t._invokeTaskZS),this._invokeTaskDlgt=i&&(i.onInvokeTask?t:t._invokeTaskDlgt),this._invokeTaskCurrZone=i&&(i.onInvokeTask?this.zone:t._invokeTaskCurrZone),this._cancelTaskZS=i&&(i.onCancelTask?i:t._cancelTaskZS),this._cancelTaskDlgt=i&&(i.onCancelTask?t:t._cancelTaskDlgt),this._cancelTaskCurrZone=i&&(i.onCancelTask?this.zone:t._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const Q=i&&i.onHasTask;(Q||t&&t._hasTaskZS)&&(this._hasTaskZS=Q?i:K,this._hasTaskDlgt=t,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=H,i.onScheduleTask||(this._scheduleTaskZS=K,this._scheduleTaskDlgt=t,this._scheduleTaskCurrZone=this.zone),i.onInvokeTask||(this._invokeTaskZS=K,this._invokeTaskDlgt=t,this._invokeTaskCurrZone=this.zone),i.onCancelTask||(this._cancelTaskZS=K,this._cancelTaskDlgt=t,this._cancelTaskCurrZone=this.zone))}fork(H,t){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,H,t):new N(H,t)}intercept(H,t,i){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,H,t,i):t}invoke(H,t,i,Q,te){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,H,t,i,Q,te):t.apply(i,Q)}handleError(H,t){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,H,t)}scheduleTask(H,t){let i=t;if(this._scheduleTaskZS)this._hasTaskZS&&i._zoneDelegates.push(this._hasTaskDlgtOwner),i=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,H,t),i||(i=t);else if(t.scheduleFn)t.scheduleFn(t);else{if(t.type!=ae)throw new Error("Task is missing scheduleFn.");ee(t)}return i}invokeTask(H,t,i,Q){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,H,t,i,Q):t.callback.apply(i,Q)}cancelTask(H,t){let i;if(this._cancelTaskZS)i=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,H,t);else{if(!t.cancelFn)throw Error("Task is not cancelable");i=t.cancelFn(t)}return i}hasTask(H,t){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,H,t)}catch(i){this.handleError(H,i)}}_updateTaskCount(H,t){const i=this._taskCounts,Q=i[H],te=i[H]=Q+t;if(te<0)throw new Error("More tasks executed then were scheduled.");0!=Q&&0!=te||this.hasTask(this.zone,{microTask:i.microTask>0,macroTask:i.macroTask>0,eventTask:i.eventTask>0,change:H})}}class q{constructor(H,t,i,Q,te,Ae){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=H,this.source=t,this.data=Q,this.scheduleFn=te,this.cancelFn=Ae,!i)throw new Error("callback is not defined");this.callback=i;const I=this;this.invoke=H===Me&&Q&&Q.useG?q.invokeTask:function(){return q.invokeTask.call(e,I,this,arguments)}}static invokeTask(H,t,i){H||(H=this),xe++;try{return H.runCount++,H.zone.runTask(H,t,i)}finally{1==xe&&F(),xe--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(de,be)}_transitionTo(H,t,i){if(this._state!==t&&this._state!==i)throw new Error(`${this.type} '${this.source}': can not transition to '${H}', expecting state '${t}'${i?" or '"+i+"'":""}, was '${this._state}'.`);this._state=H,H==de&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const ue=k("setTimeout"),oe=k("Promise"),ce=k("then");let Oe,ge=[],fe=!1;function ve(le){if(Oe||e[oe]&&(Oe=e[oe].resolve(0)),Oe){let H=Oe[ce];H||(H=Oe.then),H.call(Oe,le)}else e[ue](le,0)}function ee(le){0===xe&&0===ge.length&&ve(F),le&&ge.push(le)}function F(){if(!fe){for(fe=!0;ge.length;){const le=ge;ge=[];for(let H=0;H<le.length;H++){const t=le[H];try{t.zone.runTask(t,null,null)}catch(i){Ie.onUnhandledError(i)}}}Ie.microtaskDrainDone(),fe=!1}}const De={name:"NO ZONE"},de="notScheduled",be="scheduling",he="scheduled",L="running",pe="canceling",O="unknown",ae="microTask",Y="macroTask",Me="eventTask",Qe={},Ie={symbol:k,currentZoneFrame:()=>Ee,onUnhandledError:Se,microtaskDrainDone:Se,scheduleMicroTask:ee,showUncaughtError:()=>!N[k("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:Se,patchMethod:()=>Se,bindArguments:()=>[],patchThen:()=>Se,patchMacroTask:()=>Se,patchEventPrototype:()=>Se,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>Se,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>Se,wrapWithCurrentZone:()=>Se,filterProperties:()=>[],attachOriginToPatched:()=>Se,_redefineProperty:()=>Se,patchCallbacks:()=>Se,nativeScheduleMicroTask:ve};let Ee={parent:null,zone:new N(null,null)},Be=null,xe=0;function Se(){}a("Zone","Zone"),e.Zone=N}(globalThis);const Ze=Object.getOwnPropertyDescriptor,$e=Object.defineProperty,Re=Object.getPrototypeOf,Ke=Object.create,He=Array.prototype.slice,Je="addEventListener",Ge="removeEventListener",We=Zone.__symbol__(Je),et=Zone.__symbol__(Ge),Ne="true",Fe="false",Ye=Zone.__symbol__("");function tt(e,n){return Zone.current.wrap(e,n)}function st(e,n,o,a,f){return Zone.current.scheduleMacroTask(e,n,o,a,f)}const ie=Zone.__symbol__,Ve=typeof window<"u",Ue=Ve?window:void 0,ke=Ve&&Ue||globalThis,ze="removeAttribute";function nt(e,n){for(let o=e.length-1;o>=0;o--)"function"==typeof e[o]&&(e[o]=tt(e[o],n+"_"+o));return e}function r(e){return!e||!1!==e.writable&&!("function"==typeof e.get&&typeof e.set>"u")}const m=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,h=!("nw"in ke)&&typeof ke.process<"u"&&"[object process]"==={}.toString.call(ke.process),y=!h&&!m&&!(!Ve||!Ue.HTMLElement),_=typeof ke.process<"u"&&"[object process]"==={}.toString.call(ke.process)&&!m&&!(!Ve||!Ue.HTMLElement),A={},T=function(e){if(!(e=e||ke.event))return;let n=A[e.type];n||(n=A[e.type]=ie("ON_PROPERTY"+e.type));const o=this||e.target||ke,a=o[n];let f;return y&&o===Ue&&"error"===e.type?(f=a&&a.call(this,e.message,e.filename,e.lineno,e.colno,e.error),!0===f&&e.preventDefault()):(f=a&&a.apply(this,arguments),null!=f&&!f&&e.preventDefault()),f};function w(e,n,o){let a=Ze(e,n);if(!a&&o&&Ze(o,n)&&(a={enumerable:!0,configurable:!0}),!a||!a.configurable)return;const f=ie("on"+n+"patched");if(e.hasOwnProperty(f)&&e[f])return;delete a.writable,delete a.value;const k=a.get,x=a.set,N=n.slice(2);let K=A[N];K||(K=A[N]=ie("ON_PROPERTY"+N)),a.set=function(X){let q=this;!q&&e===ke&&(q=ke),q&&("function"==typeof q[K]&&q.removeEventListener(N,T),x&&x.call(q,null),q[K]=X,"function"==typeof X&&q.addEventListener(N,T,!1))},a.get=function(){let X=this;if(!X&&e===ke&&(X=ke),!X)return null;const q=X[K];if(q)return q;if(k){let ue=k.call(this);if(ue)return a.set.call(this,ue),"function"==typeof X[ze]&&X.removeAttribute(n),ue}return null},$e(e,n,a),e[f]=!0}function E(e,n,o){if(n)for(let a=0;a<n.length;a++)w(e,"on"+n[a],o);else{const a=[];for(const f in e)"on"==f.slice(0,2)&&a.push(f);for(let f=0;f<a.length;f++)w(e,a[f],o)}}const d=ie("originalInstance");function j(e){const n=ke[e];if(!n)return;ke[ie(e)]=n,ke[e]=function(){const f=nt(arguments,e);switch(f.length){case 0:this[d]=new n;break;case 1:this[d]=new n(f[0]);break;case 2:this[d]=new n(f[0],f[1]);break;case 3:this[d]=new n(f[0],f[1],f[2]);break;case 4:this[d]=new n(f[0],f[1],f[2],f[3]);break;default:throw new Error("Arg list too long.")}},P(ke[e],n);const o=new n(function(){});let a;for(a in o)"XMLHttpRequest"===e&&"responseBlob"===a||function(f){"function"==typeof o[f]?ke[e].prototype[f]=function(){return this[d][f].apply(this[d],arguments)}:$e(ke[e].prototype,f,{set:function(k){"function"==typeof k?(this[d][f]=tt(k,e+"."+f),P(this[d][f],k)):this[d][f]=k},get:function(){return this[d][f]}})}(a);for(a in n)"prototype"!==a&&n.hasOwnProperty(a)&&(ke[e][a]=n[a])}function W(e,n,o){let a=e;for(;a&&!a.hasOwnProperty(n);)a=Re(a);!a&&e[n]&&(a=e);const f=ie(n);let k=null;if(a&&(!(k=a[f])||!a.hasOwnProperty(f))&&(k=a[f]=a[n],r(a&&Ze(a,n)))){const N=o(k,f,n);a[n]=function(){return N(this,arguments)},P(a[n],k)}return k}function b(e,n,o){let a=null;function f(k){const x=k.data;return x.args[x.cbIdx]=function(){k.invoke.apply(this,arguments)},a.apply(x.target,x.args),k}a=W(e,n,k=>function(x,N){const K=o(x,N);return K.cbIdx>=0&&"function"==typeof N[K.cbIdx]?st(K.name,N[K.cbIdx],K,f):k.apply(x,N)})}function P(e,n){e[ie("OriginalDelegate")]=n}let U=!1,D=!1;function g(){if(U)return D;U=!0;try{const e=Ue.navigator.userAgent;(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/")||-1!==e.indexOf("Edge/"))&&(D=!0)}catch{}return D}Zone.__load_patch("ZoneAwarePromise",(e,n,o)=>{const a=Object.getOwnPropertyDescriptor,f=Object.defineProperty,x=o.symbol,N=[],K=!1!==e[x("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],X=x("Promise"),q=x("then"),ue="__creationTrace__";o.onUnhandledError=I=>{if(o.showUncaughtError()){const v=I&&I.rejection;v?console.error("Unhandled Promise rejection:",v instanceof Error?v.message:v,"; Zone:",I.zone.name,"; Task:",I.task&&I.task.source,"; Value:",v,v instanceof Error?v.stack:void 0):console.error(I)}},o.microtaskDrainDone=()=>{for(;N.length;){const I=N.shift();try{I.zone.runGuarded(()=>{throw I.throwOriginal?I.rejection:I})}catch(v){ce(v)}}};const oe=x("unhandledPromiseRejectionHandler");function ce(I){o.onUnhandledError(I);try{const v=n[oe];"function"==typeof v&&v.call(this,I)}catch{}}function ge(I){return I&&I.then}function fe(I){return I}function Oe(I){return t.reject(I)}const ve=x("state"),ee=x("value"),F=x("finally"),De=x("parentPromiseValue"),de=x("parentPromiseState"),be="Promise.then",he=null,L=!0,pe=!1,O=0;function ae(I,v){return l=>{try{Ie(I,v,l)}catch(R){Ie(I,!1,R)}}}const Y=function(){let I=!1;return function(l){return function(){I||(I=!0,l.apply(null,arguments))}}},Me="Promise resolved with itself",Qe=x("currentTaskTrace");function Ie(I,v,l){const R=Y();if(I===l)throw new TypeError(Me);if(I[ve]===he){let V=null;try{("object"==typeof l||"function"==typeof l)&&(V=l&&l.then)}catch(J){return R(()=>{Ie(I,!1,J)})(),I}if(v!==pe&&l instanceof t&&l.hasOwnProperty(ve)&&l.hasOwnProperty(ee)&&l[ve]!==he)Be(l),Ie(I,l[ve],l[ee]);else if(v!==pe&&"function"==typeof V)try{V.call(l,R(ae(I,v)),R(ae(I,!1)))}catch(J){R(()=>{Ie(I,!1,J)})()}else{I[ve]=v;const J=I[ee];if(I[ee]=l,I[F]===F&&v===L&&(I[ve]=I[de],I[ee]=I[De]),v===pe&&l instanceof Error){const B=n.currentTask&&n.currentTask.data&&n.currentTask.data[ue];B&&f(l,Qe,{configurable:!0,enumerable:!1,writable:!0,value:B})}for(let B=0;B<J.length;)xe(I,J[B++],J[B++],J[B++],J[B++]);if(0==J.length&&v==pe){I[ve]=O;let B=l;try{throw new Error("Uncaught (in promise): "+function k(I){return I&&I.toString===Object.prototype.toString?(I.constructor&&I.constructor.name||"")+": "+JSON.stringify(I):I?I.toString():Object.prototype.toString.call(I)}(l)+(l&&l.stack?"\n"+l.stack:""))}catch(ne){B=ne}K&&(B.throwOriginal=!0),B.rejection=l,B.promise=I,B.zone=n.current,B.task=n.currentTask,N.push(B),o.scheduleMicroTask()}}}return I}const Ee=x("rejectionHandledHandler");function Be(I){if(I[ve]===O){try{const v=n[Ee];v&&"function"==typeof v&&v.call(this,{rejection:I[ee],promise:I})}catch{}I[ve]=pe;for(let v=0;v<N.length;v++)I===N[v].promise&&N.splice(v,1)}}function xe(I,v,l,R,V){Be(I);const J=I[ve],B=J?"function"==typeof R?R:fe:"function"==typeof V?V:Oe;v.scheduleMicroTask(be,()=>{try{const ne=I[ee],re=!!l&&F===l[F];re&&(l[De]=ne,l[de]=J);const se=v.run(B,void 0,re&&B!==Oe&&B!==fe?[]:[ne]);Ie(l,!0,se)}catch(ne){Ie(l,!1,ne)}},l)}const le=function(){},H=e.AggregateError;class t{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(v){return v instanceof t?v:Ie(new this(null),L,v)}static reject(v){return Ie(new this(null),pe,v)}static withResolvers(){const v={};return v.promise=new t((l,R)=>{v.resolve=l,v.reject=R}),v}static any(v){if(!v||"function"!=typeof v[Symbol.iterator])return Promise.reject(new H([],"All promises were rejected"));const l=[];let R=0;try{for(let B of v)R++,l.push(t.resolve(B))}catch{return Promise.reject(new H([],"All promises were rejected"))}if(0===R)return Promise.reject(new H([],"All promises were rejected"));let V=!1;const J=[];return new t((B,ne)=>{for(let re=0;re<l.length;re++)l[re].then(se=>{V||(V=!0,B(se))},se=>{J.push(se),R--,0===R&&(V=!0,ne(new H(J,"All promises were rejected")))})})}static race(v){let l,R,V=new this((ne,re)=>{l=ne,R=re});function J(ne){l(ne)}function B(ne){R(ne)}for(let ne of v)ge(ne)||(ne=this.resolve(ne)),ne.then(J,B);return V}static all(v){return t.allWithCallback(v)}static allSettled(v){return(this&&this.prototype instanceof t?this:t).allWithCallback(v,{thenCallback:R=>({status:"fulfilled",value:R}),errorCallback:R=>({status:"rejected",reason:R})})}static allWithCallback(v,l){let R,V,J=new this((se,me)=>{R=se,V=me}),B=2,ne=0;const re=[];for(let se of v){ge(se)||(se=this.resolve(se));const me=ne;try{se.then(ye=>{re[me]=l?l.thenCallback(ye):ye,B--,0===B&&R(re)},ye=>{l?(re[me]=l.errorCallback(ye),B--,0===B&&R(re)):V(ye)})}catch(ye){V(ye)}B++,ne++}return B-=2,0===B&&R(re),J}constructor(v){const l=this;if(!(l instanceof t))throw new Error("Must be an instanceof Promise.");l[ve]=he,l[ee]=[];try{const R=Y();v&&v(R(ae(l,L)),R(ae(l,pe)))}catch(R){Ie(l,!1,R)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return t}then(v,l){let R=this.constructor?.[Symbol.species];(!R||"function"!=typeof R)&&(R=this.constructor||t);const V=new R(le),J=n.current;return this[ve]==he?this[ee].push(J,V,v,l):xe(this,J,V,v,l),V}catch(v){return this.then(null,v)}finally(v){let l=this.constructor?.[Symbol.species];(!l||"function"!=typeof l)&&(l=t);const R=new l(le);R[F]=F;const V=n.current;return this[ve]==he?this[ee].push(V,R,v,v):xe(this,V,R,v,v),R}}t.resolve=t.resolve,t.reject=t.reject,t.race=t.race,t.all=t.all;const i=e[X]=e.Promise;e.Promise=t;const Q=x("thenPatched");function te(I){const v=I.prototype,l=a(v,"then");if(l&&(!1===l.writable||!l.configurable))return;const R=v.then;v[q]=R,I.prototype.then=function(V,J){return new t((ne,re)=>{R.call(this,ne,re)}).then(V,J)},I[Q]=!0}return o.patchThen=te,i&&(te(i),W(e,"fetch",I=>function Ae(I){return function(v,l){let R=I.apply(v,l);if(R instanceof t)return R;let V=R.constructor;return V[Q]||te(V),R}}(I))),Promise[n.__symbol__("uncaughtPromiseErrors")]=N,t}),Zone.__load_patch("toString",e=>{const n=Function.prototype.toString,o=ie("OriginalDelegate"),a=ie("Promise"),f=ie("Error"),k=function(){if("function"==typeof this){const X=this[o];if(X)return"function"==typeof X?n.call(X):Object.prototype.toString.call(X);if(this===Promise){const q=e[a];if(q)return n.call(q)}if(this===Error){const q=e[f];if(q)return n.call(q)}}return n.call(this)};k[o]=n,Function.prototype.toString=k;const x=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":x.call(this)}});let Z=!1;if(typeof window<"u")try{const e=Object.defineProperty({},"passive",{get:function(){Z=!0}});window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch{Z=!1}const z={useG:!0},$={},Pe={},qe=new RegExp("^"+Ye+"(\\w+)(true|false)$"),ct=ie("propagationStopped");function at(e,n){const o=(n?n(e):e)+Fe,a=(n?n(e):e)+Ne,f=Ye+o,k=Ye+a;$[e]={},$[e][Fe]=f,$[e][Ne]=k}function s(e,n,o,a){const f=a&&a.add||Je,k=a&&a.rm||Ge,x=a&&a.listeners||"eventListeners",N=a&&a.rmAll||"removeAllListeners",K=ie(f),X="."+f+":",q="prependListener",ue="."+q+":",oe=function(ee,F,De){if(ee.isRemoved)return;const de=ee.callback;let be;"object"==typeof de&&de.handleEvent&&(ee.callback=L=>de.handleEvent(L),ee.originalDelegate=de);try{ee.invoke(ee,F,[De])}catch(L){be=L}const he=ee.options;return he&&"object"==typeof he&&he.once&&F[k].call(F,De.type,ee.originalDelegate?ee.originalDelegate:ee.callback,he),be};function ce(ee,F,De){if(!(F=F||e.event))return;const de=ee||F.target||e,be=de[$[F.type][De?Ne:Fe]];if(be){const he=[];if(1===be.length){const L=oe(be[0],de,F);L&&he.push(L)}else{const L=be.slice();for(let pe=0;pe<L.length&&(!F||!0!==F[ct]);pe++){const O=oe(L[pe],de,F);O&&he.push(O)}}if(1===he.length)throw he[0];for(let L=0;L<he.length;L++){const pe=he[L];n.nativeScheduleMicroTask(()=>{throw pe})}}}const ge=function(ee){return ce(this,ee,!1)},fe=function(ee){return ce(this,ee,!0)};function Oe(ee,F){if(!ee)return!1;let De=!0;F&&void 0!==F.useG&&(De=F.useG);const de=F&&F.vh;let be=!0;F&&void 0!==F.chkDup&&(be=F.chkDup);let he=!1;F&&void 0!==F.rt&&(he=F.rt);let L=ee;for(;L&&!L.hasOwnProperty(f);)L=Re(L);if(!L&&ee[f]&&(L=ee),!L||L[K])return!1;const pe=F&&F.eventNameToString,O={},ae=L[K]=L[f],Y=L[ie(k)]=L[k],Me=L[ie(x)]=L[x],Qe=L[ie(N)]=L[N];let Ie;F&&F.prepend&&(Ie=L[ie(F.prepend)]=L[F.prepend]);const t=De?function(l){if(!O.isExisting)return ae.call(O.target,O.eventName,O.capture?fe:ge,O.options)}:function(l){return ae.call(O.target,O.eventName,l.invoke,O.options)},i=De?function(l){if(!l.isRemoved){const R=$[l.eventName];let V;R&&(V=R[l.capture?Ne:Fe]);const J=V&&l.target[V];if(J)for(let B=0;B<J.length;B++)if(J[B]===l){J.splice(B,1),l.isRemoved=!0,0===J.length&&(l.allRemoved=!0,l.target[V]=null);break}}if(l.allRemoved)return Y.call(l.target,l.eventName,l.capture?fe:ge,l.options)}:function(l){return Y.call(l.target,l.eventName,l.invoke,l.options)},te=F&&F.diff?F.diff:function(l,R){const V=typeof R;return"function"===V&&l.callback===R||"object"===V&&l.originalDelegate===R},Ae=Zone[ie("UNPATCHED_EVENTS")],I=e[ie("PASSIVE_EVENTS")],v=function(l,R,V,J,B=!1,ne=!1){return function(){const re=this||e;let se=arguments[0];F&&F.transferEventName&&(se=F.transferEventName(se));let me=arguments[1];if(!me)return l.apply(this,arguments);if(h&&"uncaughtException"===se)return l.apply(this,arguments);let ye=!1;if("function"!=typeof me){if(!me.handleEvent)return l.apply(this,arguments);ye=!0}if(de&&!de(l,me,re,arguments))return;const rt=Z&&!!I&&-1!==I.indexOf(se),je=function Ee(l,R){return!Z&&"object"==typeof l&&l?!!l.capture:Z&&R?"boolean"==typeof l?{capture:l,passive:!0}:l?"object"==typeof l&&!1!==l.passive?{...l,passive:!0}:l:{passive:!0}:l}(arguments[2],rt),ft=je&&"object"==typeof je&&je.signal&&"object"==typeof je.signal?je.signal:void 0;if(ft?.aborted)return;if(Ae)for(let ot=0;ot<Ae.length;ot++)if(se===Ae[ot])return rt?l.call(re,se,me,je):l.apply(this,arguments);const _t=!!je&&("boolean"==typeof je||je.capture),mt=!(!je||"object"!=typeof je)&&je.once,St=Zone.current;let pt=$[se];pt||(at(se,pe),pt=$[se]);const yt=pt[_t?Ne:Fe];let Tt,lt=re[yt],gt=!1;if(lt){if(gt=!0,be)for(let ot=0;ot<lt.length;ot++)if(te(lt[ot],me))return}else lt=re[yt]=[];const kt=re.constructor.name,Et=Pe[kt];Et&&(Tt=Et[se]),Tt||(Tt=kt+R+(pe?pe(se):se)),O.options=je,mt&&(O.options.once=!1),O.target=re,O.capture=_t,O.eventName=se,O.isExisting=gt;const dt=De?z:void 0;dt&&(dt.taskData=O),ft&&(O.options.signal=void 0);const Xe=St.scheduleEventTask(Tt,me,dt,V,J);return ft&&(O.options.signal=ft,l.call(ft,"abort",()=>{Xe.zone.cancelTask(Xe)},{once:!0})),O.target=null,dt&&(dt.taskData=null),mt&&(je.once=!0),!Z&&"boolean"==typeof Xe.options||(Xe.options=je),Xe.target=re,Xe.capture=_t,Xe.eventName=se,ye&&(Xe.originalDelegate=me),ne?lt.unshift(Xe):lt.push(Xe),B?re:void 0}};return L[f]=v(ae,X,t,i,he),Ie&&(L[q]=v(Ie,ue,function(l){return Ie.call(O.target,O.eventName,l.invoke,O.options)},i,he,!0)),L[k]=function(){const l=this||e;let R=arguments[0];F&&F.transferEventName&&(R=F.transferEventName(R));const V=arguments[2],J=!!V&&("boolean"==typeof V||V.capture),B=arguments[1];if(!B)return Y.apply(this,arguments);if(de&&!de(Y,B,l,arguments))return;const ne=$[R];let re;ne&&(re=ne[J?Ne:Fe]);const se=re&&l[re];if(se)for(let me=0;me<se.length;me++){const ye=se[me];if(te(ye,B))return se.splice(me,1),ye.isRemoved=!0,0===se.length&&(ye.allRemoved=!0,l[re]=null,"string"==typeof R)&&(l[Ye+"ON_PROPERTY"+R]=null),ye.zone.cancelTask(ye),he?l:void 0}return Y.apply(this,arguments)},L[x]=function(){const l=this||e;let R=arguments[0];F&&F.transferEventName&&(R=F.transferEventName(R));const V=[],J=c(l,pe?pe(R):R);for(let B=0;B<J.length;B++){const ne=J[B];V.push(ne.originalDelegate?ne.originalDelegate:ne.callback)}return V},L[N]=function(){const l=this||e;let R=arguments[0];if(R){F&&F.transferEventName&&(R=F.transferEventName(R));const V=$[R];if(V){const ne=l[V[Fe]],re=l[V[Ne]];if(ne){const se=ne.slice();for(let me=0;me<se.length;me++){const ye=se[me];this[k].call(this,R,ye.originalDelegate?ye.originalDelegate:ye.callback,ye.options)}}if(re){const se=re.slice();for(let me=0;me<se.length;me++){const ye=se[me];this[k].call(this,R,ye.originalDelegate?ye.originalDelegate:ye.callback,ye.options)}}}}else{const V=Object.keys(l);for(let J=0;J<V.length;J++){const ne=qe.exec(V[J]);let re=ne&&ne[1];re&&"removeListener"!==re&&this[N].call(this,re)}this[N].call(this,"removeListener")}if(he)return this},P(L[f],ae),P(L[k],Y),Qe&&P(L[N],Qe),Me&&P(L[x],Me),!0}let ve=[];for(let ee=0;ee<o.length;ee++)ve[ee]=Oe(o[ee],a);return ve}function c(e,n){if(!n){const k=[];for(let x in e){const N=qe.exec(x);let K=N&&N[1];if(K&&(!n||K===n)){const X=e[x];if(X)for(let q=0;q<X.length;q++)k.push(X[q])}}return k}let o=$[n];o||(at(n),o=$[n]);const a=e[o[Fe]],f=e[o[Ne]];return a?f?a.concat(f):a.slice():f?f.slice():[]}function p(e,n){const o=e.Event;o&&o.prototype&&n.patchMethod(o.prototype,"stopImmediatePropagation",a=>function(f,k){f[ct]=!0,a&&a.apply(f,k)})}function S(e,n,o,a,f){const k=Zone.__symbol__(a);if(n[k])return;const x=n[k]=n[a];n[a]=function(N,K,X){return K&&K.prototype&&f.forEach(function(q){const ue=`${o}.${a}::`+q,oe=K.prototype;try{if(oe.hasOwnProperty(q)){const ce=e.ObjectGetOwnPropertyDescriptor(oe,q);ce&&ce.value?(ce.value=e.wrapWithCurrentZone(ce.value,ue),e._redefineProperty(K.prototype,q,ce)):oe[q]&&(oe[q]=e.wrapWithCurrentZone(oe[q],ue))}else oe[q]&&(oe[q]=e.wrapWithCurrentZone(oe[q],ue))}catch{}}),x.call(n,N,K,X)},e.attachOriginToPatched(n[a],x)}function M(e,n,o){if(!o||0===o.length)return n;const a=o.filter(k=>k.target===e);if(!a||0===a.length)return n;const f=a[0].ignoreProperties;return n.filter(k=>-1===f.indexOf(k))}function G(e,n,o,a){e&&E(e,M(e,n,o),a)}function Ce(e){return Object.getOwnPropertyNames(e).filter(n=>n.startsWith("on")&&n.length>2).map(n=>n.substring(2))}Zone.__load_patch("util",(e,n,o)=>{const a=Ce(e);o.patchOnProperties=E,o.patchMethod=W,o.bindArguments=nt,o.patchMacroTask=b;const f=n.__symbol__("BLACK_LISTED_EVENTS"),k=n.__symbol__("UNPATCHED_EVENTS");e[k]&&(e[f]=e[k]),e[f]&&(n[f]=n[k]=e[f]),o.patchEventPrototype=p,o.patchEventTarget=s,o.isIEOrEdge=g,o.ObjectDefineProperty=$e,o.ObjectGetOwnPropertyDescriptor=Ze,o.ObjectCreate=Ke,o.ArraySlice=He,o.patchClass=j,o.wrapWithCurrentZone=tt,o.filterProperties=M,o.attachOriginToPatched=P,o._redefineProperty=Object.defineProperty,o.patchCallbacks=S,o.getGlobalObjects=()=>({globalSources:Pe,zoneSymbolEventNames:$,eventNames:a,isBrowser:y,isMix:_,isNode:h,TRUE_STR:Ne,FALSE_STR:Fe,ZONE_SYMBOL_PREFIX:Ye,ADD_EVENT_LISTENER_STR:Je,REMOVE_EVENT_LISTENER_STR:Ge})});const we=ie("zoneTask");function Le(e,n,o,a){let f=null,k=null;o+=a;const x={};function N(X){const q=X.data;return q.args[0]=function(){return X.invoke.apply(this,arguments)},q.handleId=f.apply(e,q.args),X}function K(X){return k.call(e,X.data.handleId)}f=W(e,n+=a,X=>function(q,ue){if("function"==typeof ue[0]){const oe={isPeriodic:"Interval"===a,delay:"Timeout"===a||"Interval"===a?ue[1]||0:void 0,args:ue},ce=ue[0];ue[0]=function(){try{return ce.apply(this,arguments)}finally{oe.isPeriodic||("number"==typeof oe.handleId?delete x[oe.handleId]:oe.handleId&&(oe.handleId[we]=null))}};const ge=st(n,ue[0],oe,N,K);if(!ge)return ge;const fe=ge.data.handleId;return"number"==typeof fe?x[fe]=ge:fe&&(fe[we]=ge),fe&&fe.ref&&fe.unref&&"function"==typeof fe.ref&&"function"==typeof fe.unref&&(ge.ref=fe.ref.bind(fe),ge.unref=fe.unref.bind(fe)),"number"==typeof fe||fe?fe:ge}return X.apply(e,ue)}),k=W(e,o,X=>function(q,ue){const oe=ue[0];let ce;"number"==typeof oe?ce=x[oe]:(ce=oe&&oe[we],ce||(ce=oe)),ce&&"string"==typeof ce.type?"notScheduled"!==ce.state&&(ce.cancelFn&&ce.data.isPeriodic||0===ce.runCount)&&("number"==typeof oe?delete x[oe]:oe&&(oe[we]=null),ce.zone.cancelTask(ce)):X.apply(e,ue)})}Zone.__load_patch("legacy",e=>{const n=e[Zone.__symbol__("legacyPatch")];n&&n()}),Zone.__load_patch("timers",e=>{const n="set",o="clear";Le(e,n,o,"Timeout"),Le(e,n,o,"Interval"),Le(e,n,o,"Immediate")}),Zone.__load_patch("requestAnimationFrame",e=>{Le(e,"request","cancel","AnimationFrame"),Le(e,"mozRequest","mozCancel","AnimationFrame"),Le(e,"webkitRequest","webkitCancel","AnimationFrame")}),Zone.__load_patch("blocking",(e,n)=>{const o=["alert","prompt","confirm"];for(let a=0;a<o.length;a++)W(e,o[a],(k,x,N)=>function(K,X){return n.current.run(k,e,X,N)})}),Zone.__load_patch("EventTarget",(e,n,o)=>{(function ht(e,n){n.patchEventPrototype(e,n)})(e,o),function ut(e,n){if(Zone[n.symbol("patchEventTarget")])return;const{eventNames:o,zoneSymbolEventNames:a,TRUE_STR:f,FALSE_STR:k,ZONE_SYMBOL_PREFIX:x}=n.getGlobalObjects();for(let K=0;K<o.length;K++){const X=o[K],oe=x+(X+k),ce=x+(X+f);a[X]={},a[X][k]=oe,a[X][f]=ce}const N=e.EventTarget;N&&N.prototype&&n.patchEventTarget(e,n,[N&&N.prototype])}(e,o);const a=e.XMLHttpRequestEventTarget;a&&a.prototype&&o.patchEventTarget(e,o,[a.prototype])}),Zone.__load_patch("MutationObserver",(e,n,o)=>{j("MutationObserver"),j("WebKitMutationObserver")}),Zone.__load_patch("IntersectionObserver",(e,n,o)=>{j("IntersectionObserver")}),Zone.__load_patch("FileReader",(e,n,o)=>{j("FileReader")}),Zone.__load_patch("on_property",(e,n,o)=>{!function _e(e,n){if(h&&!_||Zone[e.symbol("patchEvents")])return;const o=n.__Zone_ignore_on_properties;let a=[];if(y){const f=window;a=a.concat(["Document","SVGElement","Element","HTMLElement","HTMLBodyElement","HTMLMediaElement","HTMLFrameSetElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker"]);const k=function C(){try{const e=Ue.navigator.userAgent;if(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:f,ignoreProperties:["error"]}]:[];G(f,Ce(f),o&&o.concat(k),Re(f))}a=a.concat(["XMLHttpRequest","XMLHttpRequestEventTarget","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","WebSocket"]);for(let f=0;f<a.length;f++){const k=n[a[f]];k&&k.prototype&&G(k.prototype,Ce(k.prototype),o)}}(o,e)}),Zone.__load_patch("customElements",(e,n,o)=>{!function it(e,n){const{isBrowser:o,isMix:a}=n.getGlobalObjects();(o||a)&&e.customElements&&"customElements"in e&&n.patchCallbacks(n,e.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback","formAssociatedCallback","formDisabledCallback","formResetCallback","formStateRestoreCallback"])}(e,o)}),Zone.__load_patch("XHR",(e,n)=>{!function K(X){const q=X.XMLHttpRequest;if(!q)return;const ue=q.prototype;let ce=ue[We],ge=ue[et];if(!ce){const O=X.XMLHttpRequestEventTarget;if(O){const ae=O.prototype;ce=ae[We],ge=ae[et]}}const fe="readystatechange",Oe="scheduled";function ve(O){const ae=O.data,Y=ae.target;Y[k]=!1,Y[N]=!1;const Me=Y[f];ce||(ce=Y[We],ge=Y[et]),Me&&ge.call(Y,fe,Me);const Qe=Y[f]=()=>{if(Y.readyState===Y.DONE)if(!ae.aborted&&Y[k]&&O.state===Oe){const Ee=Y[n.__symbol__("loadfalse")];if(0!==Y.status&&Ee&&Ee.length>0){const Be=O.invoke;O.invoke=function(){const xe=Y[n.__symbol__("loadfalse")];for(let Se=0;Se<xe.length;Se++)xe[Se]===O&&xe.splice(Se,1);!ae.aborted&&O.state===Oe&&Be.call(O)},Ee.push(O)}else O.invoke()}else!ae.aborted&&!1===Y[k]&&(Y[N]=!0)};return ce.call(Y,fe,Qe),Y[o]||(Y[o]=O),L.apply(Y,ae.args),Y[k]=!0,O}function ee(){}function F(O){const ae=O.data;return ae.aborted=!0,pe.apply(ae.target,ae.args)}const De=W(ue,"open",()=>function(O,ae){return O[a]=0==ae[2],O[x]=ae[1],De.apply(O,ae)}),be=ie("fetchTaskAborting"),he=ie("fetchTaskScheduling"),L=W(ue,"send",()=>function(O,ae){if(!0===n.current[he]||O[a])return L.apply(O,ae);{const Y={target:O,url:O[x],isPeriodic:!1,args:ae,aborted:!1},Me=st("XMLHttpRequest.send",ee,Y,ve,F);O&&!0===O[N]&&!Y.aborted&&Me.state===Oe&&Me.invoke()}}),pe=W(ue,"abort",()=>function(O,ae){const Y=function oe(O){return O[o]}(O);if(Y&&"string"==typeof Y.type){if(null==Y.cancelFn||Y.data&&Y.data.aborted)return;Y.zone.cancelTask(Y)}else if(!0===n.current[be])return pe.apply(O,ae)})}(e);const o=ie("xhrTask"),a=ie("xhrSync"),f=ie("xhrListener"),k=ie("xhrScheduled"),x=ie("xhrURL"),N=ie("xhrErrorBeforeScheduled")}),Zone.__load_patch("geolocation",e=>{e.navigator&&e.navigator.geolocation&&function u(e,n){const o=e.constructor.name;for(let a=0;a<n.length;a++){const f=n[a],k=e[f];if(k){if(!r(Ze(e,f)))continue;e[f]=(N=>{const K=function(){return N.apply(this,nt(arguments,o+"."+f))};return P(K,N),K})(k)}}}(e.navigator.geolocation,["getCurrentPosition","watchPosition"])}),Zone.__load_patch("PromiseRejectionEvent",(e,n)=>{function o(a){return function(f){c(e,a).forEach(x=>{const N=e.PromiseRejectionEvent;if(N){const K=new N(a,{promise:f.promise,reason:f.rejection});x.invoke(K)}})}}e.PromiseRejectionEvent&&(n[ie("unhandledPromiseRejectionHandler")]=o("unhandledrejection"),n[ie("rejectionHandledHandler")]=o("rejectionhandled"))}),Zone.__load_patch("queueMicrotask",(e,n,o)=>{!function Te(e,n){n.patchMethod(e,"queueMicrotask",o=>function(a,f){Zone.current.scheduleMicroTask("queueMicrotask",f[0])})}(e,o)})},4073:()=>{const Ze=":";Error;const qe=function(s,...c){if(qe.translate){const S=qe.translate(s,c);s=S[0],c=S[1]}let p=at(s[0],s.raw[0]);for(let S=1;S<s.length;S++)p+=c[S-1]+at(s[S],s.raw[S]);return p},ct=":";function at(s,c){return c.charAt(0)===ct?s.substring(function W(s,c){for(let p=1,S=1;p<s.length;p++,S++)if("\\"===c[S])S++;else if(s[p]===Ze)return p;throw new Error(`Unterminated $localize metadata block in "${c}".`)}(s,c)+1):s}globalThis.$localize=qe}},Ze=>{Ze(Ze.s=4050)}]);