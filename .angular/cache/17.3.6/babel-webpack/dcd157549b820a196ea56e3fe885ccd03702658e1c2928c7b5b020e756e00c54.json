{"ast":null,"code":"'use strict';\n\nlet Declaration = require('./declaration');\nlet tokenizer = require('./tokenize');\nlet Comment = require('./comment');\nlet AtRule = require('./at-rule');\nlet Root = require('./root');\nlet Rule = require('./rule');\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n};\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i];\n    let pos = token[3] || token[2];\n    if (pos) return pos;\n  }\n}\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.root = new Root();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input,\n      start: {\n        column: 1,\n        line: 1,\n        offset: 0\n      }\n    };\n  }\n  atrule(token) {\n    let node = new AtRule();\n    node.name = token[1].slice(1);\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n    this.init(node, token[2]);\n    let type;\n    let prev;\n    let shift;\n    let last = false;\n    let open = false;\n    let params = [];\n    let brackets = [];\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      type = token[0];\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}');\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n      }\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2]);\n          node.source.end.offset++;\n          this.semicolon = true;\n          break;\n        } else if (type === '{') {\n          open = true;\n          break;\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1;\n            prev = params[shift];\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift];\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2]);\n              node.source.end.offset++;\n            }\n          }\n          this.end(token);\n          break;\n        } else {\n          params.push(token);\n        }\n      } else {\n        params.push(token);\n      }\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = this.getPosition(token[3] || token[2]);\n        node.source.end.offset++;\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  }\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens);\n    if (colon === false) return;\n    let founded = 0;\n    let token;\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\n  }\n  colon(tokens) {\n    let brackets = 0;\n    let token, type, prev;\n    for (let [i, element] of tokens.entries()) {\n      token = element;\n      type = token[0];\n      if (type === '(') {\n        brackets += 1;\n      }\n      if (type === ')') {\n        brackets -= 1;\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n      prev = token;\n    }\n    return false;\n  }\n  comment(token) {\n    let node = new Comment();\n    this.init(node, token[2]);\n    node.source.end = this.getPosition(token[3] || token[2]);\n    node.source.end.offset++;\n    let text = token[1].slice(2, -2);\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  }\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input);\n  }\n  decl(tokens, customProperty) {\n    let node = new Declaration();\n    this.init(node, tokens[0][2]);\n    let last = tokens[tokens.length - 1];\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n    node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n    node.source.end.offset++;\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n    node.source.start = this.getPosition(tokens[0][2]);\n    node.prop = '';\n    while (tokens.length) {\n      let type = tokens[0][0];\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n      node.prop += tokens.shift()[1];\n    }\n    node.raws.between = '';\n    let token;\n    while (tokens.length) {\n      token = tokens.shift();\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n        node.raws.between += token[1];\n      }\n    }\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n    let firstSpaces = [];\n    let next;\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      firstSpaces.push(tokens.shift());\n    }\n    this.precheckMissedSemicolon(tokens);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        let string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0);\n        let str = '';\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0];\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break;\n          }\n          str = cache.pop()[1] + str;\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('');\n      firstSpaces = [];\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens);\n    }\n  }\n  doubleColon(token) {\n    throw this.input.error('Double colon', {\n      offset: token[2]\n    }, {\n      offset: token[2] + token[1].length\n    });\n  }\n  emptyRule(token) {\n    let node = new Rule();\n    this.init(node, token[2]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  }\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2]);\n      this.current.source.end.offset++;\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  }\n  endFile() {\n    if (this.current.parent) this.unclosedBlock();\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.root.source.end = this.getPosition(this.tokenizer.position());\n  }\n  freeSemicolon(token) {\n    this.spaces += token[1];\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1];\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset);\n    return {\n      column: pos.col,\n      line: pos.line,\n      offset\n    };\n  }\n  init(node, offset) {\n    this.current.push(node);\n    node.source = {\n      input: this.input,\n      start: this.getPosition(offset)\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  }\n  other(start) {\n    let end = false;\n    let type = null;\n    let colon = false;\n    let bracket = null;\n    let brackets = [];\n    let customProperty = start[1].startsWith('--');\n    let tokens = [];\n    let token = start;\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token;\n        brackets.push('}');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n      token = this.tokenizer.nextToken();\n    }\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0];\n          if (token !== 'space' && token !== 'comment') break;\n          this.tokenizer.back(tokens.pop());\n        }\n      }\n      this.decl(tokens, customProperty);\n    } else {\n      this.unknownWord(tokens);\n    }\n  }\n  parse() {\n    let token;\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n        case ';':\n          this.freeSemicolon(token);\n          break;\n        case '}':\n          this.end(token);\n          break;\n        case 'comment':\n          this.comment(token);\n          break;\n        case 'at-word':\n          this.atrule(token);\n          break;\n        case '{':\n          this.emptyRule(token);\n          break;\n        default:\n          this.other(token);\n          break;\n      }\n    }\n    this.endFile();\n  }\n  precheckMissedSemicolon( /* tokens */\n  ) {\n    // Hook for Safe Parser\n  }\n  raw(node, prop, tokens, customProperty) {\n    let token, type;\n    let length = tokens.length;\n    let value = '';\n    let clean = true;\n    let next, prev;\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false;\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false;\n          } else {\n            value += token[1];\n          }\n        } else {\n          clean = false;\n        }\n      } else {\n        value += token[1];\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '');\n      node.raws[prop] = {\n        raw,\n        value\n      };\n    }\n    node[prop] = value;\n  }\n  rule(tokens) {\n    tokens.pop();\n    let node = new Rule();\n    this.init(node, tokens[0][2]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  }\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  }\n\n  // Errors\n\n  spacesAndCommentsFromStart(tokens) {\n    let next;\n    let spaces = '';\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n    return spaces;\n  }\n  spacesFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  }\n  stringFrom(tokens, from) {\n    let result = '';\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n    tokens.splice(from, tokens.length - from);\n    return result;\n  }\n  unclosedBlock() {\n    let pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  }\n  unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', {\n      offset: bracket[2]\n    }, {\n      offset: bracket[2] + 1\n    });\n  }\n  unexpectedClose(token) {\n    throw this.input.error('Unexpected }', {\n      offset: token[2]\n    }, {\n      offset: token[2] + 1\n    });\n  }\n  unknownWord(tokens) {\n    throw this.input.error('Unknown word', {\n      offset: tokens[0][2]\n    }, {\n      offset: tokens[0][2] + tokens[0][1].length\n    });\n  }\n  unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', {\n      offset: token[2]\n    }, {\n      offset: token[2] + token[1].length\n    });\n  }\n}\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}