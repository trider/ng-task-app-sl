{"ast":null,"code":"import _asyncToGenerator from \"/Users/jonnygold/Code/MVDS/angular/ng-task-app-sl/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ɵSERVER_CONTEXT as _SERVER_CONTEXT, renderApplication, renderModule } from '@angular/platform-server';\nimport * as fs from 'node:fs';\nimport { dirname, join, normalize, resolve } from 'node:path';\nimport { URL } from 'node:url';\nimport Critters from 'critters';\nimport { readFile } from 'node:fs/promises';\n\n/**\n * Pattern used to extract the media query set by Critters in an `onload` handler.\n */\nconst MEDIA_SET_HANDLER_PATTERN = /^this\\.media=[\"'](.*)[\"'];?$/;\n/**\n * Name of the attribute used to save the Critters media query so it can be re-assigned on load.\n */\nconst CSP_MEDIA_ATTR = 'ngCspMedia';\n/**\n * Script text used to change the media value of the link tags.\n *\n * NOTE:\n * We do not use `document.querySelectorAll('link').forEach((s) => s.addEventListener('load', ...)`\n * because this does not always fire on Chome.\n * See: https://github.com/angular/angular-cli/issues/26932 and https://crbug.com/1521256\n */\nconst LINK_LOAD_SCRIPT_CONTENT = ['(() => {', `  const CSP_MEDIA_ATTR = '${CSP_MEDIA_ATTR}';`, '  const documentElement = document.documentElement;', '  const listener = (e) => {', '    const target = e.target;', `    if (!target || target.tagName !== 'LINK' || !target.hasAttribute(CSP_MEDIA_ATTR)) {`, '     return;', '    }', '    target.media = target.getAttribute(CSP_MEDIA_ATTR);', '    target.removeAttribute(CSP_MEDIA_ATTR);',\n// Remove onload listener when there are no longer styles that need to be loaded.\n'    if (!document.head.querySelector(`link[${CSP_MEDIA_ATTR}]`)) {', `      documentElement.removeEventListener('load', listener);`, '    }', '  };',\n//  We use an event with capturing (the true parameter) because load events don't bubble.\n`  documentElement.addEventListener('load', listener, true);`, '})();'].join('\\n');\nclass CrittersExtended extends Critters {\n  optionsExtended;\n  resourceCache;\n  warnings = [];\n  errors = [];\n  initialEmbedLinkedStylesheet;\n  addedCspScriptsDocuments = new WeakSet();\n  documentNonces = new WeakMap();\n  constructor(optionsExtended, resourceCache) {\n    super({\n      logger: {\n        warn: s => this.warnings.push(s),\n        error: s => this.errors.push(s),\n        info: () => {}\n      },\n      logLevel: 'warn',\n      path: optionsExtended.outputPath,\n      publicPath: optionsExtended.deployUrl,\n      compress: !!optionsExtended.minify,\n      pruneSource: false,\n      reduceInlineStyles: false,\n      mergeStylesheets: false,\n      // Note: if `preload` changes to anything other than `media`, the logic in\n      // `embedLinkedStylesheetOverride` will have to be updated.\n      preload: 'media',\n      noscriptFallback: true,\n      inlineFonts: true\n    });\n    this.optionsExtended = optionsExtended;\n    this.resourceCache = resourceCache;\n    // We can't use inheritance to override `embedLinkedStylesheet`, because it's not declared in\n    // the `Critters` .d.ts which means that we can't call the `super` implementation. TS doesn't\n    // allow for `super` to be cast to a different type.\n    this.initialEmbedLinkedStylesheet = this.embedLinkedStylesheet;\n    this.embedLinkedStylesheet = this.embedLinkedStylesheetOverride;\n  }\n  readFile(path) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let resourceContent = _this.resourceCache.get(path);\n      if (resourceContent === undefined) {\n        resourceContent = yield readFile(path, 'utf-8');\n        _this.resourceCache.set(path, resourceContent);\n      }\n      return resourceContent;\n    })();\n  }\n  /**\n   * Override of the Critters `embedLinkedStylesheet` method\n   * that makes it work with Angular's CSP APIs.\n   */\n  embedLinkedStylesheetOverride = (() => {\n    var _this2 = this;\n    return function () {\n      var _ref = _asyncToGenerator(function* (link, document) {\n        if (link.getAttribute('media') === 'print' && link.next?.name === 'noscript') {\n          // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64\n          // NB: this is only needed for the webpack based builders.\n          const media = link.getAttribute('onload')?.match(MEDIA_SET_HANDLER_PATTERN);\n          if (media) {\n            link.removeAttribute('onload');\n            link.setAttribute('media', media[1]);\n            link?.next?.remove();\n          }\n        }\n        const returnValue = yield _this2.initialEmbedLinkedStylesheet(link, document);\n        const cspNonce = _this2.findCspNonce(document);\n        if (cspNonce) {\n          const crittersMedia = link.getAttribute('onload')?.match(MEDIA_SET_HANDLER_PATTERN);\n          if (crittersMedia) {\n            // If there's a Critters-generated `onload` handler and the file has an Angular CSP nonce,\n            // we have to remove the handler, because it's incompatible with CSP. We save the value\n            // in a different attribute and we generate a script tag with the nonce that uses\n            // `addEventListener` to apply the media query instead.\n            link.removeAttribute('onload');\n            link.setAttribute(CSP_MEDIA_ATTR, crittersMedia[1]);\n            _this2.conditionallyInsertCspLoadingScript(document, cspNonce, link);\n          }\n          // Ideally we would hook in at the time Critters inserts the `style` tags, but there isn't\n          // a way of doing that at the moment so we fall back to doing it any time a `link` tag is\n          // inserted. We mitigate it by only iterating the direct children of the `<head>` which\n          // should be pretty shallow.\n          document.head.children.forEach(child => {\n            if (child.tagName === 'style' && !child.hasAttribute('nonce')) {\n              child.setAttribute('nonce', cspNonce);\n            }\n          });\n        }\n        return returnValue;\n      });\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  })();\n  /**\n   * Finds the CSP nonce for a specific document.\n   */\n  findCspNonce(document) {\n    if (this.documentNonces.has(document)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.documentNonces.get(document);\n    }\n    // HTML attribute are case-insensitive, but the parser used by Critters is case-sensitive.\n    const nonceElement = document.querySelector('[ngCspNonce], [ngcspnonce]');\n    const cspNonce = nonceElement?.getAttribute('ngCspNonce') || nonceElement?.getAttribute('ngcspnonce') || null;\n    this.documentNonces.set(document, cspNonce);\n    return cspNonce;\n  }\n  /**\n   * Inserts the `script` tag that swaps the critical CSS at runtime,\n   * if one hasn't been inserted into the document already.\n   */\n  conditionallyInsertCspLoadingScript(document, nonce, link) {\n    if (this.addedCspScriptsDocuments.has(document)) {\n      return;\n    }\n    if (document.head.textContent.includes(LINK_LOAD_SCRIPT_CONTENT)) {\n      // Script was already added during the build.\n      this.addedCspScriptsDocuments.add(document);\n      return;\n    }\n    const script = document.createElement('script');\n    script.setAttribute('nonce', nonce);\n    script.textContent = LINK_LOAD_SCRIPT_CONTENT;\n    // Prepend the script to the head since it needs to\n    // run as early as possible, before the `link` tags.\n    document.head.insertBefore(script, link);\n    this.addedCspScriptsDocuments.add(document);\n  }\n}\nclass InlineCriticalCssProcessor {\n  options;\n  resourceCache = new Map();\n  constructor(options) {\n    this.options = options;\n  }\n  process(html, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const critters = new CrittersExtended({\n        ..._this3.options,\n        ...options\n      }, _this3.resourceCache);\n      const content = yield critters.process(html);\n      return {\n        content,\n        errors: critters.errors.length ? critters.errors : undefined,\n        warnings: critters.warnings.length ? critters.warnings : undefined\n      };\n    })();\n  }\n}\nconst PERFORMANCE_MARK_PREFIX = '🅰️';\nfunction printPerformanceLogs() {\n  let maxWordLength = 0;\n  const benchmarks = [];\n  for (const {\n    name,\n    duration\n  } of performance.getEntriesByType('measure')) {\n    if (!name.startsWith(PERFORMANCE_MARK_PREFIX)) {\n      continue;\n    }\n    // `🅰️:Retrieve SSG Page` -> `Retrieve SSG Page:`\n    const step = name.slice(PERFORMANCE_MARK_PREFIX.length + 1) + ':';\n    if (step.length > maxWordLength) {\n      maxWordLength = step.length;\n    }\n    benchmarks.push([step, `${duration.toFixed(1)}ms`]);\n    performance.clearMeasures(name);\n  }\n  /* eslint-disable no-console */\n  console.log('********** Performance results **********');\n  for (const [step, value] of benchmarks) {\n    const spaces = maxWordLength - step.length + 5;\n    console.log(step + ' '.repeat(spaces) + value);\n  }\n  console.log('*****************************************');\n  /* eslint-enable no-console */\n}\nfunction runMethodAndMeasurePerf(_x3, _x4) {\n  return _runMethodAndMeasurePerf.apply(this, arguments);\n}\nfunction _runMethodAndMeasurePerf() {\n  _runMethodAndMeasurePerf = _asyncToGenerator(function* (label, asyncMethod) {\n    const labelName = `${PERFORMANCE_MARK_PREFIX}:${label}`;\n    const startLabel = `start:${labelName}`;\n    const endLabel = `end:${labelName}`;\n    try {\n      performance.mark(startLabel);\n      return yield asyncMethod();\n    } finally {\n      performance.mark(endLabel);\n      performance.measure(labelName, startLabel, endLabel);\n      performance.clearMarks(startLabel);\n      performance.clearMarks(endLabel);\n    }\n  });\n  return _runMethodAndMeasurePerf.apply(this, arguments);\n}\nfunction noopRunMethodAndMeasurePerf(label, asyncMethod) {\n  return asyncMethod();\n}\nconst SSG_MARKER_REGEXP = /ng-server-context=[\"']\\w*\\|?ssg\\|?\\w*[\"']/;\n/**\n * A common engine to use to server render an application.\n */\nclass CommonEngine {\n  options;\n  templateCache = new Map();\n  inlineCriticalCssProcessor;\n  pageIsSSG = new Map();\n  constructor(options) {\n    this.options = options;\n    this.inlineCriticalCssProcessor = new InlineCriticalCssProcessor({\n      minify: false\n    });\n  }\n  /**\n   * Render an HTML document for a specific URL with specified\n   * render options\n   */\n  render(opts) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const enablePerformanceProfiler = _this4.options?.enablePerformanceProfiler;\n      const runMethod = enablePerformanceProfiler ? runMethodAndMeasurePerf : noopRunMethodAndMeasurePerf;\n      let html = yield runMethod('Retrieve SSG Page', () => _this4.retrieveSSGPage(opts));\n      if (html === undefined) {\n        html = yield runMethod('Render Page', () => _this4.renderApplication(opts));\n        if (opts.inlineCriticalCss !== false) {\n          const {\n            content,\n            errors,\n            warnings\n          } = yield runMethod('Inline Critical CSS', () =>\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          _this4.inlineCriticalCss(html, opts));\n          html = content;\n          // eslint-disable-next-line no-console\n          warnings?.forEach(m => console.warn(m));\n          // eslint-disable-next-line no-console\n          errors?.forEach(m => console.error(m));\n        }\n      }\n      if (enablePerformanceProfiler) {\n        printPerformanceLogs();\n      }\n      return html;\n    })();\n  }\n  inlineCriticalCss(html, opts) {\n    return this.inlineCriticalCssProcessor.process(html, {\n      outputPath: opts.publicPath ?? (opts.documentFilePath ? dirname(opts.documentFilePath) : '')\n    });\n  }\n  retrieveSSGPage(opts) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        publicPath,\n        documentFilePath,\n        url\n      } = opts;\n      if (!publicPath || !documentFilePath || url === undefined) {\n        return undefined;\n      }\n      const {\n        pathname\n      } = new URL(url, 'resolve://');\n      // Do not use `resolve` here as otherwise it can lead to path traversal vulnerability.\n      // See: https://portswigger.net/web-security/file-path-traversal\n      const pagePath = join(publicPath, pathname, 'index.html');\n      if (_this5.pageIsSSG.get(pagePath)) {\n        // Serve pre-rendered page.\n        return fs.promises.readFile(pagePath, 'utf-8');\n      }\n      if (!pagePath.startsWith(normalize(publicPath))) {\n        // Potential path traversal detected.\n        return undefined;\n      }\n      if (pagePath === resolve(documentFilePath) || !(yield exists(pagePath))) {\n        // View matches with prerender path or file does not exist.\n        _this5.pageIsSSG.set(pagePath, false);\n        return undefined;\n      }\n      // Static file exists.\n      const content = yield fs.promises.readFile(pagePath, 'utf-8');\n      const isSSG = SSG_MARKER_REGEXP.test(content);\n      _this5.pageIsSSG.set(pagePath, isSSG);\n      return isSSG ? content : undefined;\n    })();\n  }\n  renderApplication(opts) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const moduleOrFactory = _this6.options?.bootstrap ?? opts.bootstrap;\n      if (!moduleOrFactory) {\n        throw new Error('A module or bootstrap option must be provided.');\n      }\n      const extraProviders = [{\n        provide: _SERVER_CONTEXT,\n        useValue: 'ssr'\n      }, ...(opts.providers ?? []), ...(_this6.options?.providers ?? [])];\n      let document = opts.document;\n      if (!document && opts.documentFilePath) {\n        document = yield _this6.getDocument(opts.documentFilePath);\n      }\n      const commonRenderingOptions = {\n        url: opts.url,\n        document\n      };\n      return isBootstrapFn(moduleOrFactory) ? renderApplication(moduleOrFactory, {\n        platformProviders: extraProviders,\n        ...commonRenderingOptions\n      }) : renderModule(moduleOrFactory, {\n        extraProviders,\n        ...commonRenderingOptions\n      });\n    })();\n  }\n  /** Retrieve the document from the cache or the filesystem */\n  getDocument(filePath) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      let doc = _this7.templateCache.get(filePath);\n      if (!doc) {\n        doc = yield fs.promises.readFile(filePath, 'utf-8');\n        _this7.templateCache.set(filePath, doc);\n      }\n      return doc;\n    })();\n  }\n}\nfunction exists(_x5) {\n  return _exists.apply(this, arguments);\n}\nfunction _exists() {\n  _exists = _asyncToGenerator(function* (path) {\n    try {\n      yield fs.promises.access(path, fs.constants.F_OK);\n      return true;\n    } catch {\n      return false;\n    }\n  });\n  return _exists.apply(this, arguments);\n}\nfunction isBootstrapFn(value) {\n  // We can differentiate between a module and a bootstrap function by reading compiler-generated `ɵmod` static property:\n  return typeof value === 'function' && !('ɵmod' in value);\n}\nexport { CommonEngine };\n//# sourceMappingURL=ssr.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}