{"ast":null,"code":"export const xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nconst xmlCodeMap = new Map([[34, \"&quot;\"], [38, \"&amp;\"], [39, \"&apos;\"], [60, \"&lt;\"], [62, \"&gt;\"]]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexport const getCodePoint =\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) :\n// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n(c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800 ? (c.charCodeAt(index) - 0xd800) * 0x400 + c.charCodeAt(index + 1) - 0xdc00 + 0x10000 : c.charCodeAt(index);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexport function encodeXML(str) {\n  let ret = \"\";\n  let lastIdx = 0;\n  let match;\n  while ((match = xmlReplacer.exec(str)) !== null) {\n    const i = match.index;\n    const char = str.charCodeAt(i);\n    const next = xmlCodeMap.get(char);\n    if (next !== undefined) {\n      ret += str.substring(lastIdx, i) + next;\n      lastIdx = i + 1;\n    } else {\n      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;\n      // Increase by 1 if we have a surrogate pair\n      lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n    }\n  }\n  return ret + str.substr(lastIdx);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexport const escape = encodeXML;\n/**\n * Creates a function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n *\n * @param regex Regular expression to match characters to escape.\n * @param map Map of characters to escape to their entities.\n *\n * @returns Function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n */\nfunction getEscaper(regex, map) {\n  return function escape(data) {\n    let match;\n    let lastIdx = 0;\n    let result = \"\";\n    while (match = regex.exec(data)) {\n      if (lastIdx !== match.index) {\n        result += data.substring(lastIdx, match.index);\n      }\n      // We know that this character will be in the map.\n      result += map.get(match[0].charCodeAt(0));\n      // Every match will be of length 1\n      lastIdx = match.index + 1;\n    }\n    return result + data.substring(lastIdx);\n  };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexport const escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([[34, \"&quot;\"], [38, \"&amp;\"], [160, \"&nbsp;\"]]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([[38, \"&amp;\"], [60, \"&lt;\"], [62, \"&gt;\"], [160, \"&nbsp;\"]]));\n//# sourceMappingURL=escape.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}