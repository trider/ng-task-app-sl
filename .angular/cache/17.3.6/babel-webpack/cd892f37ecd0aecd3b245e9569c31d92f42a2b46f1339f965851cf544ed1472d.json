{"ast":null,"code":"'use strict';\n\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\nconst ESCAPES = new Map([['n', '\\n'], ['r', '\\r'], ['t', '\\t'], ['b', '\\b'], ['f', '\\f'], ['v', '\\v'], ['0', '\\0'], ['\\\\', '\\\\'], ['e', '\\u001B'], ['a', '\\u0007']]);\nfunction unescape(c) {\n  const u = c[0] === 'u';\n  const bracket = c[1] === '{';\n  if (u && !bracket && c.length === 5 || c[0] === 'x' && c.length === 3) {\n    return String.fromCharCode(parseInt(c.slice(1), 16));\n  }\n  if (u && bracket) {\n    return String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n  }\n  return ESCAPES.get(c) || c;\n}\nfunction parseArguments(name, arguments_) {\n  const results = [];\n  const chunks = arguments_.trim().split(/\\s*,\\s*/g);\n  let matches;\n  for (const chunk of chunks) {\n    const number = Number(chunk);\n    if (!Number.isNaN(number)) {\n      results.push(number);\n    } else if (matches = chunk.match(STRING_REGEX)) {\n      results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n    } else {\n      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n    }\n  }\n  return results;\n}\nfunction parseStyle(style) {\n  STYLE_REGEX.lastIndex = 0;\n  const results = [];\n  let matches;\n  while ((matches = STYLE_REGEX.exec(style)) !== null) {\n    const name = matches[1];\n    if (matches[2]) {\n      const args = parseArguments(name, matches[2]);\n      results.push([name].concat(args));\n    } else {\n      results.push([name]);\n    }\n  }\n  return results;\n}\nfunction buildStyle(chalk, styles) {\n  const enabled = {};\n  for (const layer of styles) {\n    for (const style of layer.styles) {\n      enabled[style[0]] = layer.inverse ? null : style.slice(1);\n    }\n  }\n  let current = chalk;\n  for (const [styleName, styles] of Object.entries(enabled)) {\n    if (!Array.isArray(styles)) {\n      continue;\n    }\n    if (!(styleName in current)) {\n      throw new Error(`Unknown Chalk style: ${styleName}`);\n    }\n    current = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n  }\n  return current;\n}\nmodule.exports = (chalk, temporary) => {\n  const styles = [];\n  const chunks = [];\n  let chunk = [];\n\n  // eslint-disable-next-line max-params\n  temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n    if (escapeCharacter) {\n      chunk.push(unescape(escapeCharacter));\n    } else if (style) {\n      const string = chunk.join('');\n      chunk = [];\n      chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n      styles.push({\n        inverse,\n        styles: parseStyle(style)\n      });\n    } else if (close) {\n      if (styles.length === 0) {\n        throw new Error('Found extraneous } in Chalk template literal');\n      }\n      chunks.push(buildStyle(chalk, styles)(chunk.join('')));\n      chunk = [];\n      styles.pop();\n    } else {\n      chunk.push(character);\n    }\n  });\n  chunks.push(chunk.join(''));\n  if (styles.length > 0) {\n    const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n    throw new Error(errMessage);\n  }\n  return chunks.join('');\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}