{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/jonnygold/Code/MVDS/angular/ng-task-app-sl/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nlet {\n  isClean,\n  my\n} = require('./symbols');\nlet MapGenerator = require('./map-generator');\nlet stringify = require('./stringify');\nlet Container = require('./container');\nlet Document = require('./document');\nlet warnOnce = require('./warn-once');\nlet Result = require('./result');\nlet parse = require('./parse');\nlet Root = require('./root');\nconst TYPE_TO_CLASS_NAME = {\n  atrule: 'AtRule',\n  comment: 'Comment',\n  decl: 'Declaration',\n  document: 'Document',\n  root: 'Root',\n  rule: 'Rule'\n};\nconst PLUGIN_PROPS = {\n  AtRule: true,\n  AtRuleExit: true,\n  Comment: true,\n  CommentExit: true,\n  Declaration: true,\n  DeclarationExit: true,\n  Document: true,\n  DocumentExit: true,\n  Once: true,\n  OnceExit: true,\n  postcssPlugin: true,\n  prepare: true,\n  Root: true,\n  RootExit: true,\n  Rule: true,\n  RuleExit: true\n};\nconst NOT_VISITORS = {\n  Once: true,\n  postcssPlugin: true,\n  prepare: true\n};\nconst CHILDREN = 0;\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function';\n}\nfunction getEvents(node) {\n  let key = false;\n  let type = TYPE_TO_CLASS_NAME[node.type];\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase();\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase();\n  }\n  if (key && node.append) {\n    return [type, type + '-' + key, CHILDREN, type + 'Exit', type + 'Exit-' + key];\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit'];\n  } else {\n    return [type, type + 'Exit'];\n  }\n}\nfunction toStack(node) {\n  let events;\n  if (node.type === 'document') {\n    events = ['Document', CHILDREN, 'DocumentExit'];\n  } else if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit'];\n  } else {\n    events = getEvents(node);\n  }\n  return {\n    eventIndex: 0,\n    events,\n    iterator: 0,\n    node,\n    visitorIndex: 0,\n    visitors: []\n  };\n}\nfunction cleanMarks(node) {\n  node[isClean] = false;\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i));\n  return node;\n}\nlet postcss = {};\nlet LazyResult = /*#__PURE__*/(() => {\n  class LazyResult {\n    constructor(processor, css, opts) {\n      this.stringified = false;\n      this.processed = false;\n      let root;\n      if (typeof css === 'object' && css !== null && (css.type === 'root' || css.type === 'document')) {\n        root = cleanMarks(css);\n      } else if (css instanceof LazyResult || css instanceof Result) {\n        root = cleanMarks(css.root);\n        if (css.map) {\n          if (typeof opts.map === 'undefined') opts.map = {};\n          if (!opts.map.inline) opts.map.inline = false;\n          opts.map.prev = css.map;\n        }\n      } else {\n        let parser = parse;\n        if (opts.syntax) parser = opts.syntax.parse;\n        if (opts.parser) parser = opts.parser;\n        if (parser.parse) parser = parser.parse;\n        try {\n          root = parser(css, opts);\n        } catch (error) {\n          this.processed = true;\n          this.error = error;\n        }\n        if (root && !root[my]) {\n          /* c8 ignore next 2 */\n          Container.rebuild(root);\n        }\n      }\n      this.result = new Result(processor, root, opts);\n      this.helpers = {\n        ...postcss,\n        postcss,\n        result: this.result\n      };\n      this.plugins = this.processor.plugins.map(plugin => {\n        if (typeof plugin === 'object' && plugin.prepare) {\n          return {\n            ...plugin,\n            ...plugin.prepare(this.result)\n          };\n        } else {\n          return plugin;\n        }\n      });\n    }\n    async() {\n      if (this.error) return Promise.reject(this.error);\n      if (this.processed) return Promise.resolve(this.result);\n      if (!this.processing) {\n        this.processing = this.runAsync();\n      }\n      return this.processing;\n    }\n    catch(onRejected) {\n      return this.async().catch(onRejected);\n    }\n    finally(onFinally) {\n      return this.async().then(onFinally, onFinally);\n    }\n    getAsyncError() {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n    handleError(error, node) {\n      let plugin = this.result.lastPlugin;\n      try {\n        if (node) node.addToError(error);\n        this.error = error;\n        if (error.name === 'CssSyntaxError' && !error.plugin) {\n          error.plugin = plugin.postcssPlugin;\n          error.setMessage();\n        } else if (plugin.postcssVersion) {\n          if (process.env.NODE_ENV !== 'production') {\n            let pluginName = plugin.postcssPlugin;\n            let pluginVer = plugin.postcssVersion;\n            let runtimeVer = this.result.processor.version;\n            let a = pluginVer.split('.');\n            let b = runtimeVer.split('.');\n            if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n              // eslint-disable-next-line no-console\n              console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n            }\n          }\n        }\n      } catch (err) {\n        /* c8 ignore next 3 */\n        // eslint-disable-next-line no-console\n        if (console && console.error) console.error(err);\n      }\n      return error;\n    }\n    prepareVisitors() {\n      this.listeners = {};\n      let add = (plugin, type, cb) => {\n        if (!this.listeners[type]) this.listeners[type] = [];\n        this.listeners[type].push([plugin, cb]);\n      };\n      for (let plugin of this.plugins) {\n        if (typeof plugin === 'object') {\n          for (let event in plugin) {\n            if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n              throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);\n            }\n            if (!NOT_VISITORS[event]) {\n              if (typeof plugin[event] === 'object') {\n                for (let filter in plugin[event]) {\n                  if (filter === '*') {\n                    add(plugin, event, plugin[event][filter]);\n                  } else {\n                    add(plugin, event + '-' + filter.toLowerCase(), plugin[event][filter]);\n                  }\n                }\n              } else if (typeof plugin[event] === 'function') {\n                add(plugin, event, plugin[event]);\n              }\n            }\n          }\n        }\n      }\n      this.hasListener = Object.keys(this.listeners).length > 0;\n    }\n    runAsync() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.plugin = 0;\n        for (let i = 0; i < _this.plugins.length; i++) {\n          let plugin = _this.plugins[i];\n          let promise = _this.runOnRoot(plugin);\n          if (isPromise(promise)) {\n            try {\n              yield promise;\n            } catch (error) {\n              throw _this.handleError(error);\n            }\n          }\n        }\n        _this.prepareVisitors();\n        if (_this.hasListener) {\n          let root = _this.result.root;\n          while (!root[isClean]) {\n            root[isClean] = true;\n            let stack = [toStack(root)];\n            while (stack.length > 0) {\n              let promise = _this.visitTick(stack);\n              if (isPromise(promise)) {\n                try {\n                  yield promise;\n                } catch (e) {\n                  let node = stack[stack.length - 1].node;\n                  throw _this.handleError(e, node);\n                }\n              }\n            }\n          }\n          if (_this.listeners.OnceExit) {\n            for (let [plugin, visitor] of _this.listeners.OnceExit) {\n              _this.result.lastPlugin = plugin;\n              try {\n                if (root.type === 'document') {\n                  let roots = root.nodes.map(subRoot => visitor(subRoot, _this.helpers));\n                  yield Promise.all(roots);\n                } else {\n                  yield visitor(root, _this.helpers);\n                }\n              } catch (e) {\n                throw _this.handleError(e);\n              }\n            }\n          }\n        }\n        _this.processed = true;\n        return _this.stringify();\n      })();\n    }\n    runOnRoot(plugin) {\n      this.result.lastPlugin = plugin;\n      try {\n        if (typeof plugin === 'object' && plugin.Once) {\n          if (this.result.root.type === 'document') {\n            let roots = this.result.root.nodes.map(root => plugin.Once(root, this.helpers));\n            if (isPromise(roots[0])) {\n              return Promise.all(roots);\n            }\n            return roots;\n          }\n          return plugin.Once(this.result.root, this.helpers);\n        } else if (typeof plugin === 'function') {\n          return plugin(this.result.root, this.result);\n        }\n      } catch (error) {\n        throw this.handleError(error);\n      }\n    }\n    stringify() {\n      if (this.error) throw this.error;\n      if (this.stringified) return this.result;\n      this.stringified = true;\n      this.sync();\n      let opts = this.result.opts;\n      let str = stringify;\n      if (opts.syntax) str = opts.syntax.stringify;\n      if (opts.stringifier) str = opts.stringifier;\n      if (str.stringify) str = str.stringify;\n      let map = new MapGenerator(str, this.result.root, this.result.opts);\n      let data = map.generate();\n      this.result.css = data[0];\n      this.result.map = data[1];\n      return this.result;\n    }\n    sync() {\n      if (this.error) throw this.error;\n      if (this.processed) return this.result;\n      this.processed = true;\n      if (this.processing) {\n        throw this.getAsyncError();\n      }\n      for (let plugin of this.plugins) {\n        let promise = this.runOnRoot(plugin);\n        if (isPromise(promise)) {\n          throw this.getAsyncError();\n        }\n      }\n      this.prepareVisitors();\n      if (this.hasListener) {\n        let root = this.result.root;\n        while (!root[isClean]) {\n          root[isClean] = true;\n          this.walkSync(root);\n        }\n        if (this.listeners.OnceExit) {\n          if (root.type === 'document') {\n            for (let subRoot of root.nodes) {\n              this.visitSync(this.listeners.OnceExit, subRoot);\n            }\n          } else {\n            this.visitSync(this.listeners.OnceExit, root);\n          }\n        }\n      }\n      return this.result;\n    }\n    then(onFulfilled, onRejected) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!('from' in this.opts)) {\n          warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n        }\n      }\n      return this.async().then(onFulfilled, onRejected);\n    }\n    toString() {\n      return this.css;\n    }\n    visitSync(visitors, node) {\n      for (let [plugin, visitor] of visitors) {\n        this.result.lastPlugin = plugin;\n        let promise;\n        try {\n          promise = visitor(node, this.helpers);\n        } catch (e) {\n          throw this.handleError(e, node.proxyOf);\n        }\n        if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n          return true;\n        }\n        if (isPromise(promise)) {\n          throw this.getAsyncError();\n        }\n      }\n    }\n    visitTick(stack) {\n      let visit = stack[stack.length - 1];\n      let {\n        node,\n        visitors\n      } = visit;\n      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n        stack.pop();\n        return;\n      }\n      if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n        let [plugin, visitor] = visitors[visit.visitorIndex];\n        visit.visitorIndex += 1;\n        if (visit.visitorIndex === visitors.length) {\n          visit.visitors = [];\n          visit.visitorIndex = 0;\n        }\n        this.result.lastPlugin = plugin;\n        try {\n          return visitor(node.toProxy(), this.helpers);\n        } catch (e) {\n          throw this.handleError(e, node);\n        }\n      }\n      if (visit.iterator !== 0) {\n        let iterator = visit.iterator;\n        let child;\n        while (child = node.nodes[node.indexes[iterator]]) {\n          node.indexes[iterator] += 1;\n          if (!child[isClean]) {\n            child[isClean] = true;\n            stack.push(toStack(child));\n            return;\n          }\n        }\n        visit.iterator = 0;\n        delete node.indexes[iterator];\n      }\n      let events = visit.events;\n      while (visit.eventIndex < events.length) {\n        let event = events[visit.eventIndex];\n        visit.eventIndex += 1;\n        if (event === CHILDREN) {\n          if (node.nodes && node.nodes.length) {\n            node[isClean] = true;\n            visit.iterator = node.getIterator();\n          }\n          return;\n        } else if (this.listeners[event]) {\n          visit.visitors = this.listeners[event];\n          return;\n        }\n      }\n      stack.pop();\n    }\n    walkSync(node) {\n      node[isClean] = true;\n      let events = getEvents(node);\n      for (let event of events) {\n        if (event === CHILDREN) {\n          if (node.nodes) {\n            node.each(child => {\n              if (!child[isClean]) this.walkSync(child);\n            });\n          }\n        } else {\n          let visitors = this.listeners[event];\n          if (visitors) {\n            if (this.visitSync(visitors, node.toProxy())) return;\n          }\n        }\n      }\n    }\n    warnings() {\n      return this.sync().warnings();\n    }\n    get content() {\n      return this.stringify().content;\n    }\n    get css() {\n      return this.stringify().css;\n    }\n    get map() {\n      return this.stringify().map;\n    }\n    get messages() {\n      return this.sync().messages;\n    }\n    get opts() {\n      return this.result.opts;\n    }\n    get processor() {\n      return this.result.processor;\n    }\n    get root() {\n      return this.sync().root;\n    }\n    get [Symbol.toStringTag]() {\n      return 'LazyResult';\n    }\n  }\n  LazyResult.registerPostcss = dependant => {\n    postcss = dependant;\n  };\n  return LazyResult;\n})();\nmodule.exports = LazyResult;\nLazyResult.default = LazyResult;\nRoot.registerLazyResult(LazyResult);\nDocument.registerLazyResult(LazyResult);","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}