{"ast":null,"code":"'use strict';\n\nlet {\n  SourceMapConsumer,\n  SourceMapGenerator\n} = require('source-map-js');\nlet {\n  dirname,\n  relative,\n  resolve,\n  sep\n} = require('path');\nlet {\n  pathToFileURL\n} = require('url');\nlet Input = require('./input');\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nlet pathAvailable = Boolean(dirname && resolve && relative && sep);\nclass MapGenerator {\n  constructor(stringify, root, opts, cssString) {\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n    this.css = cssString;\n    this.originalCSS = cssString;\n    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n    this.memoizedFileURLs = new Map();\n    this.memoizedPaths = new Map();\n    this.memoizedURLs = new Map();\n  }\n  addAnnotation() {\n    let content;\n    if (this.isInline()) {\n      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation;\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root);\n    } else {\n      content = this.outputFile() + '.map';\n    }\n    let eol = '\\n';\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n';\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n  }\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file));\n      let root = prev.root || dirname(prev.file);\n      let map;\n      if (this.mapOpts.sourcesContent === false) {\n        map = new SourceMapConsumer(prev.text);\n        if (map.sourcesContent) {\n          map.sourcesContent = null;\n        }\n      } else {\n        map = prev.consumer();\n      }\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)));\n    }\n  }\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return;\n    if (this.root) {\n      let node;\n      for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i];\n        if (node.type !== 'comment') continue;\n        if (node.text.indexOf('# sourceMappingURL=') === 0) {\n          this.root.removeChild(i);\n        }\n      }\n    } else if (this.css) {\n      this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, '');\n    }\n  }\n  generate() {\n    this.clearAnnotation();\n    if (pathAvailable && sourceMapAvailable && this.isMap()) {\n      return this.generateMap();\n    } else {\n      let result = '';\n      this.stringify(this.root, i => {\n        result += i;\n      });\n      return [result];\n    }\n  }\n  generateMap() {\n    if (this.root) {\n      this.generateString();\n    } else if (this.previous().length === 1) {\n      let prev = this.previous()[0].consumer();\n      prev.file = this.outputFile();\n      this.map = SourceMapGenerator.fromSourceMap(prev);\n    } else {\n      this.map = new SourceMapGenerator({\n        file: this.outputFile()\n      });\n      this.map.addMapping({\n        generated: {\n          column: 0,\n          line: 1\n        },\n        original: {\n          column: 0,\n          line: 1\n        },\n        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>'\n      });\n    }\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.root && this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n    if (this.isInline()) {\n      return [this.css];\n    } else {\n      return [this.css, this.map];\n    }\n  }\n  generateString() {\n    this.css = '';\n    this.map = new SourceMapGenerator({\n      file: this.outputFile()\n    });\n    let line = 1;\n    let column = 1;\n    let noSource = '<no source>';\n    let mapping = {\n      generated: {\n        column: 0,\n        line: 0\n      },\n      original: {\n        column: 0,\n        line: 0\n      },\n      source: ''\n    };\n    let lines, last;\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str;\n      if (node && type !== 'end') {\n        mapping.generated.line = line;\n        mapping.generated.column = column - 1;\n        if (node.source && node.source.start) {\n          mapping.source = this.sourcePath(node);\n          mapping.original.line = node.source.start.line;\n          mapping.original.column = node.source.start.column - 1;\n          this.map.addMapping(mapping);\n        } else {\n          mapping.source = noSource;\n          mapping.original.line = 1;\n          mapping.original.column = 0;\n          this.map.addMapping(mapping);\n        }\n      }\n      lines = str.match(/\\n/g);\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf('\\n');\n        column = str.length - last;\n      } else {\n        column += str.length;\n      }\n      if (node && type !== 'start') {\n        let p = node.parent || {\n          raws: {}\n        };\n        let childless = node.type === 'decl' || node.type === 'atrule' && !node.nodes;\n        if (!childless || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            mapping.source = this.sourcePath(node);\n            mapping.original.line = node.source.end.line;\n            mapping.original.column = node.source.end.column - 1;\n            mapping.generated.line = line;\n            mapping.generated.column = column - 2;\n            this.map.addMapping(mapping);\n          } else {\n            mapping.source = noSource;\n            mapping.original.line = 1;\n            mapping.original.column = 0;\n            mapping.generated.line = line;\n            mapping.generated.column = column - 1;\n            this.map.addMapping(mapping);\n          }\n        }\n      }\n    });\n  }\n  isAnnotation() {\n    if (this.isInline()) {\n      return true;\n    }\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation;\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation);\n    }\n    return true;\n  }\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline;\n    }\n    let annotation = this.mapOpts.annotation;\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false;\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline);\n    }\n    return true;\n  }\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map;\n    }\n    return this.previous().length > 0;\n  }\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent());\n    }\n    return true;\n  }\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to);\n    } else if (this.opts.from) {\n      return this.path(this.opts.from);\n    } else {\n      return 'to.css';\n    }\n  }\n  path(file) {\n    if (this.mapOpts.absolute) return file;\n    if (file.charCodeAt(0) === 60 /* `<` */) return file;\n    if (/^\\w+:\\/\\//.test(file)) return file;\n    let cached = this.memoizedPaths.get(file);\n    if (cached) return cached;\n    let from = this.opts.to ? dirname(this.opts.to) : '.';\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation));\n    }\n    let path = relative(from, file);\n    this.memoizedPaths.set(file, path);\n    return path;\n  }\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n      if (this.root) {\n        this.root.walk(node => {\n          if (node.source && node.source.input.map) {\n            let map = node.source.input.map;\n            if (!this.previousMaps.includes(map)) {\n              this.previousMaps.push(map);\n            }\n          }\n        });\n      } else {\n        let input = new Input(this.originalCSS, this.opts);\n        if (input.map) this.previousMaps.push(input.map);\n      }\n    }\n    return this.previousMaps;\n  }\n  setSourcesContent() {\n    let already = {};\n    if (this.root) {\n      this.root.walk(node => {\n        if (node.source) {\n          let from = node.source.input.from;\n          if (from && !already[from]) {\n            already[from] = true;\n            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));\n            this.map.setSourceContent(fromUrl, node.source.input.css);\n          }\n        }\n      });\n    } else if (this.css) {\n      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>';\n      this.map.setSourceContent(from, this.css);\n    }\n  }\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from);\n    } else if (this.usesFileUrls) {\n      return this.toFileUrl(node.source.input.from);\n    } else {\n      return this.toUrl(this.path(node.source.input.from));\n    }\n  }\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64');\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)));\n    }\n  }\n  toFileUrl(path) {\n    let cached = this.memoizedFileURLs.get(path);\n    if (cached) return cached;\n    if (pathToFileURL) {\n      let fileURL = pathToFileURL(path).toString();\n      this.memoizedFileURLs.set(path, fileURL);\n      return fileURL;\n    } else {\n      throw new Error('`map.absolute` option is not available in this PostCSS build');\n    }\n  }\n  toUrl(path) {\n    let cached = this.memoizedURLs.get(path);\n    if (cached) return cached;\n    if (sep === '\\\\') {\n      path = path.replace(/\\\\/g, '/');\n    }\n    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n    this.memoizedURLs.set(path, url);\n    return url;\n  }\n}\nmodule.exports = MapGenerator;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}