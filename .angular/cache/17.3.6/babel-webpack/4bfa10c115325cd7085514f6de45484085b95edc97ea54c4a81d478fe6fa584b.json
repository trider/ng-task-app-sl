{"ast":null,"code":"import { SelectorType, AttributeAction } from \"./types\";\nconst attribValChars = [\"\\\\\", '\"'];\nconst pseudoValChars = [...attribValChars, \"(\", \")\"];\nconst charsToEscapeInAttributeValue = new Set(attribValChars.map(c => c.charCodeAt(0)));\nconst charsToEscapeInPseudoValue = new Set(pseudoValChars.map(c => c.charCodeAt(0)));\nconst charsToEscapeInName = new Set([...pseudoValChars, \"~\", \"^\", \"$\", \"*\", \"+\", \"!\", \"|\", \":\", \"[\", \"]\", \" \", \".\"].map(c => c.charCodeAt(0)));\n/**\n * Turns `selector` back into a string.\n *\n * @param selector Selector to stringify.\n */\nexport function stringify(selector) {\n  return selector.map(token => token.map(stringifyToken).join(\"\")).join(\", \");\n}\nfunction stringifyToken(token, index, arr) {\n  switch (token.type) {\n    // Simple types\n    case SelectorType.Child:\n      return index === 0 ? \"> \" : \" > \";\n    case SelectorType.Parent:\n      return index === 0 ? \"< \" : \" < \";\n    case SelectorType.Sibling:\n      return index === 0 ? \"~ \" : \" ~ \";\n    case SelectorType.Adjacent:\n      return index === 0 ? \"+ \" : \" + \";\n    case SelectorType.Descendant:\n      return \" \";\n    case SelectorType.ColumnCombinator:\n      return index === 0 ? \"|| \" : \" || \";\n    case SelectorType.Universal:\n      // Return an empty string if the selector isn't needed.\n      return token.namespace === \"*\" && index + 1 < arr.length && \"name\" in arr[index + 1] ? \"\" : `${getNamespace(token.namespace)}*`;\n    case SelectorType.Tag:\n      return getNamespacedName(token);\n    case SelectorType.PseudoElement:\n      return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null ? \"\" : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;\n    case SelectorType.Pseudo:\n      return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null ? \"\" : `(${typeof token.data === \"string\" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data)})`}`;\n    case SelectorType.Attribute:\n      {\n        if (token.name === \"id\" && token.action === AttributeAction.Equals && token.ignoreCase === \"quirks\" && !token.namespace) {\n          return `#${escapeName(token.value, charsToEscapeInName)}`;\n        }\n        if (token.name === \"class\" && token.action === AttributeAction.Element && token.ignoreCase === \"quirks\" && !token.namespace) {\n          return `.${escapeName(token.value, charsToEscapeInName)}`;\n        }\n        const name = getNamespacedName(token);\n        if (token.action === AttributeAction.Exists) {\n          return `[${name}]`;\n        }\n        return `[${name}${getActionValue(token.action)}=\"${escapeName(token.value, charsToEscapeInAttributeValue)}\"${token.ignoreCase === null ? \"\" : token.ignoreCase ? \" i\" : \" s\"}]`;\n      }\n  }\n}\nfunction getActionValue(action) {\n  switch (action) {\n    case AttributeAction.Equals:\n      return \"\";\n    case AttributeAction.Element:\n      return \"~\";\n    case AttributeAction.Start:\n      return \"^\";\n    case AttributeAction.End:\n      return \"$\";\n    case AttributeAction.Any:\n      return \"*\";\n    case AttributeAction.Not:\n      return \"!\";\n    case AttributeAction.Hyphen:\n      return \"|\";\n    case AttributeAction.Exists:\n      throw new Error(\"Shouldn't be here\");\n  }\n}\nfunction getNamespacedName(token) {\n  return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;\n}\nfunction getNamespace(namespace) {\n  return namespace !== null ? `${namespace === \"*\" ? \"*\" : escapeName(namespace, charsToEscapeInName)}|` : \"\";\n}\nfunction escapeName(str, charsToEscape) {\n  let lastIdx = 0;\n  let ret = \"\";\n  for (let i = 0; i < str.length; i++) {\n    if (charsToEscape.has(str.charCodeAt(i))) {\n      ret += `${str.slice(lastIdx, i)}\\\\${str.charAt(i)}`;\n      lastIdx = i + 1;\n    }\n  }\n  return ret.length > 0 ? ret + str.slice(lastIdx) : str;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}