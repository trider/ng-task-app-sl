{"ast":null,"code":"import _asyncToGenerator from \"/Users/jonnygold/Code/MVDS/angular/ng-task-app-sl/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { readFile } from 'fs';\nimport { selectOne, selectAll } from 'css-select';\nimport { parseDocument, DomUtils } from 'htmlparser2';\nimport { Element, Text } from 'domhandler';\nimport render from 'dom-serializer';\nimport path from 'path';\nimport { parse as parse$1, stringify } from 'postcss';\nimport mediaParser from 'postcss-media-query-parser';\nimport chalk from 'chalk';\nvar SelectorType = /*#__PURE__*/function (SelectorType) {\n  SelectorType[\"Attribute\"] = \"attribute\";\n  SelectorType[\"Pseudo\"] = \"pseudo\";\n  SelectorType[\"PseudoElement\"] = \"pseudo-element\";\n  SelectorType[\"Tag\"] = \"tag\";\n  SelectorType[\"Universal\"] = \"universal\";\n  // Traversals\n  SelectorType[\"Adjacent\"] = \"adjacent\";\n  SelectorType[\"Child\"] = \"child\";\n  SelectorType[\"Descendant\"] = \"descendant\";\n  SelectorType[\"Parent\"] = \"parent\";\n  SelectorType[\"Sibling\"] = \"sibling\";\n  SelectorType[\"ColumnCombinator\"] = \"column-combinator\";\n  return SelectorType;\n}(SelectorType || {});\nvar AttributeAction = /*#__PURE__*/function (AttributeAction) {\n  AttributeAction[\"Any\"] = \"any\";\n  AttributeAction[\"Element\"] = \"element\";\n  AttributeAction[\"End\"] = \"end\";\n  AttributeAction[\"Equals\"] = \"equals\";\n  AttributeAction[\"Exists\"] = \"exists\";\n  AttributeAction[\"Hyphen\"] = \"hyphen\";\n  AttributeAction[\"Not\"] = \"not\";\n  AttributeAction[\"Start\"] = \"start\";\n  return AttributeAction;\n}(AttributeAction || {});\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([[126 /* Tilde */, AttributeAction.Element], [94 /* Circumflex */, AttributeAction.Start], [36 /* Dollar */, AttributeAction.End], [42 /* Asterisk */, AttributeAction.Any], [33 /* ExclamationMark */, AttributeAction.Not], [124 /* Pipe */, AttributeAction.Hyphen]]);\n// Pseudos, whose data property is parsed as well.\nconst unpackPseudos = new Set([\"has\", \"not\", \"matches\", \"is\", \"where\", \"host\", \"host-context\"]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nfunction isTraversal(selector) {\n  switch (selector.type) {\n    case SelectorType.Adjacent:\n    case SelectorType.Child:\n    case SelectorType.Descendant:\n    case SelectorType.Parent:\n    case SelectorType.Sibling:\n    case SelectorType.ColumnCombinator:\n      return true;\n    default:\n      return false;\n  }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n  const high = parseInt(escaped, 16) - 0x10000;\n  // NaN means non-codepoint\n  return high !== high || escapedWhitespace ? escaped : high < 0 ?\n  // BMP codepoint\n  String.fromCharCode(high + 0x10000) :\n  // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n}\nfunction unescapeCSS(str) {\n  return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n  return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\nfunction isWhitespace(c) {\n  return c === 32 /* Space */ || c === 9 /* Tab */ || c === 10 /* NewLine */ || c === 12 /* FormFeed */ || c === 13 /* CarriageReturn */;\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nfunction parse(selector) {\n  const subselects = [];\n  const endIndex = parseSelector(subselects, `${selector}`, 0);\n  if (endIndex < selector.length) {\n    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n  }\n  return subselects;\n}\nfunction parseSelector(subselects, selector, selectorIndex) {\n  let tokens = [];\n  function getName(offset) {\n    const match = selector.slice(selectorIndex + offset).match(reName);\n    if (!match) {\n      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n    }\n    const [name] = match;\n    selectorIndex += offset + name.length;\n    return unescapeCSS(name);\n  }\n  function stripWhitespace(offset) {\n    selectorIndex += offset;\n    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {\n      selectorIndex++;\n    }\n  }\n  function readValueWithParenthesis() {\n    selectorIndex += 1;\n    const start = selectorIndex;\n    let counter = 1;\n    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n      if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ && !isEscaped(selectorIndex)) {\n        counter++;\n      } else if (selector.charCodeAt(selectorIndex) === 41 /* RightParenthesis */ && !isEscaped(selectorIndex)) {\n        counter--;\n      }\n    }\n    if (counter) {\n      throw new Error(\"Parenthesis not matched\");\n    }\n    return unescapeCSS(selector.slice(start, selectorIndex - 1));\n  }\n  function isEscaped(pos) {\n    let slashCount = 0;\n    while (selector.charCodeAt(--pos) === 92 /* BackSlash */) slashCount++;\n    return (slashCount & 1) === 1;\n  }\n  function ensureNotTraversal() {\n    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n      throw new Error(\"Did not expect successive traversals.\");\n    }\n  }\n  function addTraversal(type) {\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {\n      tokens[tokens.length - 1].type = type;\n      return;\n    }\n    ensureNotTraversal();\n    tokens.push({\n      type\n    });\n  }\n  function addSpecialAttribute(name, action) {\n    tokens.push({\n      type: SelectorType.Attribute,\n      name,\n      action,\n      value: getName(1),\n      namespace: null,\n      ignoreCase: \"quirks\"\n    });\n  }\n  /**\n   * We have finished parsing the current part of the selector.\n   *\n   * Remove descendant tokens at the end if they exist,\n   * and return the last index, so that parsing can be\n   * picked up from here.\n   */\n  function finalizeSubselector() {\n    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {\n      tokens.pop();\n    }\n    if (tokens.length === 0) {\n      throw new Error(\"Empty sub-selector\");\n    }\n    subselects.push(tokens);\n  }\n  stripWhitespace(0);\n  if (selector.length === selectorIndex) {\n    return selectorIndex;\n  }\n  loop: while (selectorIndex < selector.length) {\n    const firstChar = selector.charCodeAt(selectorIndex);\n    switch (firstChar) {\n      // Whitespace\n      case 32 /* Space */:\n      case 9 /* Tab */:\n      case 10 /* NewLine */:\n      case 12 /* FormFeed */:\n      case 13 /* CarriageReturn */:\n        {\n          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {\n            ensureNotTraversal();\n            tokens.push({\n              type: SelectorType.Descendant\n            });\n          }\n          stripWhitespace(1);\n          break;\n        }\n      // Traversals\n      case 62 /* GreaterThan */:\n        {\n          addTraversal(SelectorType.Child);\n          stripWhitespace(1);\n          break;\n        }\n      case 60 /* LessThan */:\n        {\n          addTraversal(SelectorType.Parent);\n          stripWhitespace(1);\n          break;\n        }\n      case 126 /* Tilde */:\n        {\n          addTraversal(SelectorType.Sibling);\n          stripWhitespace(1);\n          break;\n        }\n      case 43 /* Plus */:\n        {\n          addTraversal(SelectorType.Adjacent);\n          stripWhitespace(1);\n          break;\n        }\n      // Special attribute selectors: .class, #id\n      case 46 /* Period */:\n        {\n          addSpecialAttribute(\"class\", AttributeAction.Element);\n          break;\n        }\n      case 35 /* Hash */:\n        {\n          addSpecialAttribute(\"id\", AttributeAction.Equals);\n          break;\n        }\n      case 91 /* LeftSquareBracket */:\n        {\n          stripWhitespace(1);\n          // Determine attribute name and namespace\n          let name;\n          let namespace = null;\n          if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n            // Equivalent to no namespace\n            name = getName(1);\n          } else if (selector.startsWith(\"*|\", selectorIndex)) {\n            namespace = \"*\";\n            name = getName(2);\n          } else {\n            name = getName(0);\n            if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ && selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {\n              namespace = name;\n              name = getName(1);\n            }\n          }\n          stripWhitespace(0);\n          // Determine comparison operation\n          let action = AttributeAction.Exists;\n          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n          if (possibleAction) {\n            action = possibleAction;\n            if (selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {\n              throw new Error(\"Expected `=`\");\n            }\n            stripWhitespace(2);\n          } else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n            action = AttributeAction.Equals;\n            stripWhitespace(1);\n          }\n          // Determine value\n          let value = \"\";\n          let ignoreCase = null;\n          if (action !== \"exists\") {\n            if (isQuote(selector.charCodeAt(selectorIndex))) {\n              const quote = selector.charCodeAt(selectorIndex);\n              let sectionEnd = selectorIndex + 1;\n              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {\n                sectionEnd += 1;\n              }\n              if (selector.charCodeAt(sectionEnd) !== quote) {\n                throw new Error(\"Attribute value didn't end\");\n              }\n              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n              selectorIndex = sectionEnd + 1;\n            } else {\n              const valueStart = selectorIndex;\n              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */ || isEscaped(selectorIndex))) {\n                selectorIndex += 1;\n              }\n              value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n            }\n            stripWhitespace(0);\n            // See if we have a force ignore flag\n            const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n            // If the forceIgnore flag is set (either `i` or `s`), use that value\n            if (forceIgnore === 115 /* LowerS */) {\n              ignoreCase = false;\n              stripWhitespace(1);\n            } else if (forceIgnore === 105 /* LowerI */) {\n              ignoreCase = true;\n              stripWhitespace(1);\n            }\n          }\n          if (selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */) {\n            throw new Error(\"Attribute selector didn't terminate\");\n          }\n          selectorIndex += 1;\n          const attributeSelector = {\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value,\n            namespace,\n            ignoreCase\n          };\n          tokens.push(attributeSelector);\n          break;\n        }\n      case 58 /* Colon */:\n        {\n          if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n            tokens.push({\n              type: SelectorType.PseudoElement,\n              name: getName(2).toLowerCase(),\n              data: selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ ? readValueWithParenthesis() : null\n            });\n            continue;\n          }\n          const name = getName(1).toLowerCase();\n          let data = null;\n          if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */) {\n            if (unpackPseudos.has(name)) {\n              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n              }\n              data = [];\n              selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n              if (selector.charCodeAt(selectorIndex) !== 41 /* RightParenthesis */) {\n                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n              }\n              selectorIndex += 1;\n            } else {\n              data = readValueWithParenthesis();\n              if (stripQuotesFromPseudos.has(name)) {\n                const quot = data.charCodeAt(0);\n                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {\n                  data = data.slice(1, -1);\n                }\n              }\n              data = unescapeCSS(data);\n            }\n          }\n          tokens.push({\n            type: SelectorType.Pseudo,\n            name,\n            data\n          });\n          break;\n        }\n      case 44 /* Comma */:\n        {\n          finalizeSubselector();\n          tokens = [];\n          stripWhitespace(1);\n          break;\n        }\n      default:\n        {\n          if (selector.startsWith(\"/*\", selectorIndex)) {\n            const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n            if (endIndex < 0) {\n              throw new Error(\"Comment was not terminated\");\n            }\n            selectorIndex = endIndex + 2;\n            // Remove leading whitespace\n            if (tokens.length === 0) {\n              stripWhitespace(0);\n            }\n            break;\n          }\n          let namespace = null;\n          let name;\n          if (firstChar === 42 /* Asterisk */) {\n            selectorIndex += 1;\n            name = \"*\";\n          } else if (firstChar === 124 /* Pipe */) {\n            name = \"\";\n            if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n              addTraversal(SelectorType.ColumnCombinator);\n              stripWhitespace(2);\n              break;\n            }\n          } else if (reName.test(selector.slice(selectorIndex))) {\n            name = getName(0);\n          } else {\n            break loop;\n          }\n          if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ && selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n            namespace = name;\n            if (selector.charCodeAt(selectorIndex + 1) === 42 /* Asterisk */) {\n              name = \"*\";\n              selectorIndex += 2;\n            } else {\n              name = getName(1);\n            }\n          }\n          tokens.push(name === \"*\" ? {\n            type: SelectorType.Universal,\n            namespace\n          } : {\n            type: SelectorType.Tag,\n            name,\n            namespace\n          });\n        }\n    }\n  }\n  finalizeSubselector();\n  return selectorIndex;\n}\n\n/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\nlet classCache = null;\nlet idCache = null;\nfunction buildCache(container) {\n  classCache = new Set();\n  idCache = new Set();\n  const queue = [container];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node.hasAttribute('class')) {\n      const classList = node.getAttribute('class').trim().split(' ');\n      classList.forEach(cls => {\n        classCache.add(cls);\n      });\n    }\n    if (node.hasAttribute('id')) {\n      const id = node.getAttribute('id').trim();\n      idCache.add(id);\n    }\n    queue.push(...node.children.filter(child => child.type === 'tag'));\n  }\n}\n\n/**\n * Parse HTML into a mutable, serializable DOM Document.\n * The DOM implementation is an htmlparser2 DOM enhanced with basic DOM mutation methods.\n * @param {String} html   HTML to parse into a Document instance\n */\nfunction createDocument(html) {\n  const document = /** @type {HTMLDocument} */parseDocument(html, {\n    decodeEntities: false\n  });\n  defineProperties(document, DocumentExtensions);\n\n  // Extend Element.prototype with DOM manipulation methods.\n  defineProperties(Element.prototype, ElementExtensions);\n\n  // Critters container is the viewport to evaluate critical CSS\n  let crittersContainer = document.querySelector('[data-critters-container]');\n  if (!crittersContainer) {\n    document.documentElement.setAttribute('data-critters-container', '');\n    crittersContainer = document.documentElement;\n  }\n  document.crittersContainer = crittersContainer;\n  buildCache(crittersContainer);\n  return document;\n}\n\n/**\n * Serialize a Document to an HTML String\n * @param {HTMLDocument} document   A Document, such as one created via `createDocument()`\n */\nfunction serializeDocument(document) {\n  return render(document, {\n    decodeEntities: false\n  });\n}\n\n/** @typedef {treeAdapter.Document & typeof ElementExtensions} HTMLDocument */\n\n/**\n * Methods and descriptors to mix into Element.prototype\n * @private\n */\nconst ElementExtensions = {\n  /** @extends treeAdapter.Element.prototype */\n\n  nodeName: {\n    get() {\n      return this.tagName.toUpperCase();\n    }\n  },\n  id: reflectedProperty('id'),\n  className: reflectedProperty('class'),\n  insertBefore(child, referenceNode) {\n    if (!referenceNode) return this.appendChild(child);\n    DomUtils.prepend(referenceNode, child);\n    return child;\n  },\n  appendChild(child) {\n    DomUtils.appendChild(this, child);\n    return child;\n  },\n  removeChild(child) {\n    DomUtils.removeElement(child);\n  },\n  remove() {\n    DomUtils.removeElement(this);\n  },\n  textContent: {\n    get() {\n      return DomUtils.getText(this);\n    },\n    set(text) {\n      this.children = [];\n      DomUtils.appendChild(this, new Text(text));\n    }\n  },\n  setAttribute(name, value) {\n    if (this.attribs == null) this.attribs = {};\n    if (value == null) value = '';\n    this.attribs[name] = value;\n  },\n  removeAttribute(name) {\n    if (this.attribs != null) {\n      delete this.attribs[name];\n    }\n  },\n  getAttribute(name) {\n    return this.attribs != null && this.attribs[name];\n  },\n  hasAttribute(name) {\n    return this.attribs != null && this.attribs[name] != null;\n  },\n  getAttributeNode(name) {\n    const value = this.getAttribute(name);\n    if (value != null) return {\n      specified: true,\n      value\n    };\n  },\n  exists(sel) {\n    return cachedQuerySelector(sel, this);\n  },\n  querySelector(sel) {\n    return selectOne(sel, this);\n  },\n  querySelectorAll(sel) {\n    return selectAll(sel, this);\n  }\n};\n\n/**\n * Methods and descriptors to mix into the global document instance\n * @private\n */\nconst DocumentExtensions = {\n  /** @extends treeAdapter.Document.prototype */\n\n  // document is just an Element in htmlparser2, giving it a nodeType of ELEMENT_NODE.\n  // TODO: verify if these are needed for css-select\n  nodeType: {\n    get() {\n      return 9;\n    }\n  },\n  contentType: {\n    get() {\n      return 'text/html';\n    }\n  },\n  nodeName: {\n    get() {\n      return '#document';\n    }\n  },\n  documentElement: {\n    get() {\n      // Find the first <html> element within the document\n      return this.children.find(child => String(child.tagName).toLowerCase() === 'html');\n    }\n  },\n  head: {\n    get() {\n      return this.querySelector('head');\n    }\n  },\n  body: {\n    get() {\n      return this.querySelector('body');\n    }\n  },\n  createElement(name) {\n    return new Element(name);\n  },\n  createTextNode(text) {\n    // there is no dedicated createTextNode equivalent exposed in htmlparser2's DOM\n    return new Text(text);\n  },\n  exists(sel) {\n    return cachedQuerySelector(sel, this);\n  },\n  querySelector(sel) {\n    return selectOne(sel, this);\n  },\n  querySelectorAll(sel) {\n    if (sel === ':root') {\n      return this;\n    }\n    return selectAll(sel, this);\n  }\n};\n\n/**\n * Essentially `Object.defineProperties()`, except function values are assigned as value descriptors for convenience.\n * @private\n */\nfunction defineProperties(obj, properties) {\n  for (const i in properties) {\n    const value = properties[i];\n    Object.defineProperty(obj, i, typeof value === 'function' ? {\n      value\n    } : value);\n  }\n}\n\n/**\n * Create a property descriptor defining a getter/setter pair alias for a named attribute.\n * @private\n */\nfunction reflectedProperty(attributeName) {\n  return {\n    get() {\n      return this.getAttribute(attributeName);\n    },\n    set(value) {\n      this.setAttribute(attributeName, value);\n    }\n  };\n}\nfunction cachedQuerySelector(sel, node) {\n  const selectorTokens = parse(sel);\n  for (const tokens of selectorTokens) {\n    // Check if the selector is a class selector\n    if (tokens.length === 1) {\n      const token = tokens[0];\n      if (token.type === 'attribute' && token.name === 'class') {\n        return classCache.has(token.value);\n      }\n      if (token.type === 'attribute' && token.name === 'id') {\n        return idCache.has(token.value);\n      }\n    }\n  }\n  return !!selectOne(sel, node);\n}\n\n/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n/**\n * Parse a textual CSS Stylesheet into a Stylesheet instance.\n * Stylesheet is a mutable postcss AST with format similar to CSSOM.\n * @see https://github.com/postcss/postcss/\n * @private\n * @param {String} stylesheet\n * @returns {css.Stylesheet} ast\n */\nfunction parseStylesheet(stylesheet) {\n  return parse$1(stylesheet);\n}\n\n/**\n * Serialize a postcss Stylesheet to a String of CSS.\n * @private\n * @param {css.Stylesheet} ast          A Stylesheet to serialize, such as one returned from `parseStylesheet()`\n * @param {Object} options              Options used by the stringify logic\n * @param {Boolean} [options.compress]  Compress CSS output (removes comments, whitespace, etc)\n */\nfunction serializeStylesheet(ast, options) {\n  let cssStr = '';\n  stringify(ast, (result, node, type) => {\n    var _node$raws;\n    if ((node == null ? void 0 : node.type) === 'decl' && node.value.includes('</style>')) {\n      return;\n    }\n    if (!options.compress) {\n      cssStr += result;\n      return;\n    }\n\n    // Simple minification logic\n    if ((node == null ? void 0 : node.type) === 'comment') return;\n    if ((node == null ? void 0 : node.type) === 'decl') {\n      const prefix = node.prop + node.raws.between;\n      cssStr += result.replace(prefix, prefix.trim());\n      return;\n    }\n    if (type === 'start') {\n      if (node.type === 'rule' && node.selectors) {\n        cssStr += node.selectors.join(',') + '{';\n      } else {\n        cssStr += result.replace(/\\s\\{$/, '{');\n      }\n      return;\n    }\n    if (type === 'end' && result === '}' && node != null && (_node$raws = node.raws) != null && _node$raws.semicolon) {\n      cssStr = cssStr.slice(0, -1);\n    }\n    cssStr += result.trim();\n  });\n  return cssStr;\n}\n\n/**\n * Converts a walkStyleRules() iterator to mark nodes with `.$$remove=true` instead of actually removing them.\n * This means they can be removed in a second pass, allowing the first pass to be nondestructive (eg: to preserve mirrored sheets).\n * @private\n * @param {Function} iterator   Invoked on each node in the tree. Return `false` to remove that node.\n * @returns {(rule) => void} nonDestructiveIterator\n */\nfunction markOnly(predicate) {\n  return rule => {\n    const sel = rule.selectors;\n    if (predicate(rule) === false) {\n      rule.$$remove = true;\n    }\n    rule.$$markedSelectors = rule.selectors;\n    if (rule._other) {\n      rule._other.$$markedSelectors = rule._other.selectors;\n    }\n    rule.selectors = sel;\n  };\n}\n\n/**\n * Apply filtered selectors to a rule from a previous markOnly run.\n * @private\n * @param {css.Rule} rule The Rule to apply marked selectors to (if they exist).\n */\nfunction applyMarkedSelectors(rule) {\n  if (rule.$$markedSelectors) {\n    rule.selectors = rule.$$markedSelectors;\n  }\n  if (rule._other) {\n    applyMarkedSelectors(rule._other);\n  }\n}\n\n/**\n * Recursively walk all rules in a stylesheet.\n * @private\n * @param {css.Rule} node       A Stylesheet or Rule to descend into.\n * @param {Function} iterator   Invoked on each node in the tree. Return `false` to remove that node.\n */\nfunction walkStyleRules(node, iterator) {\n  node.nodes = node.nodes.filter(rule => {\n    if (hasNestedRules(rule)) {\n      walkStyleRules(rule, iterator);\n    }\n    rule._other = undefined;\n    rule.filterSelectors = filterSelectors;\n    return iterator(rule) !== false;\n  });\n}\n\n/**\n * Recursively walk all rules in two identical stylesheets, filtering nodes into one or the other based on a predicate.\n * @private\n * @param {css.Rule} node       A Stylesheet or Rule to descend into.\n * @param {css.Rule} node2      A second tree identical to `node`\n * @param {Function} iterator   Invoked on each node in the tree. Return `false` to remove that node from the first tree, true to remove it from the second.\n */\nfunction walkStyleRulesWithReverseMirror(node, node2, iterator) {\n  if (node2 === null) return walkStyleRules(node, iterator);\n  [node.nodes, node2.nodes] = splitFilter(node.nodes, node2.nodes, (rule, index, rules, rules2) => {\n    const rule2 = rules2[index];\n    if (hasNestedRules(rule)) {\n      walkStyleRulesWithReverseMirror(rule, rule2, iterator);\n    }\n    rule._other = rule2;\n    rule.filterSelectors = filterSelectors;\n    return iterator(rule) !== false;\n  });\n}\n\n// Checks if a node has nested rules, like @media\n// @keyframes are an exception since they are evaluated as a whole\nfunction hasNestedRules(rule) {\n  var _rule$nodes;\n  return ((_rule$nodes = rule.nodes) == null ? void 0 : _rule$nodes.length) && rule.name !== 'keyframes' && rule.name !== '-webkit-keyframes' && rule.nodes.some(n => n.type === 'rule' || n.type === 'atrule');\n}\n\n// Like [].filter(), but applies the opposite filtering result to a second copy of the Array without a second pass.\n// This is just a quicker version of generating the compliment of the set returned from a filter operation.\nfunction splitFilter(a, b, predicate) {\n  const aOut = [];\n  const bOut = [];\n  for (let index = 0; index < a.length; index++) {\n    if (predicate(a[index], index, a, b)) {\n      aOut.push(a[index]);\n    } else {\n      bOut.push(a[index]);\n    }\n  }\n  return [aOut, bOut];\n}\n\n// can be invoked on a style rule to subset its selectors (with reverse mirroring)\nfunction filterSelectors(predicate) {\n  if (this._other) {\n    const [a, b] = splitFilter(this.selectors, this._other.selectors, predicate);\n    this.selectors = a;\n    this._other.selectors = b;\n  } else {\n    this.selectors = this.selectors.filter(predicate);\n  }\n}\nconst MEDIA_TYPES = new Set(['all', 'print', 'screen', 'speech']);\nconst MEDIA_KEYWORDS = new Set(['and', 'not', ',']);\nconst MEDIA_FEATURES = new Set(['width', 'aspect-ratio', 'color', 'color-index', 'grid', 'height', 'monochrome', 'orientation', 'resolution', 'scan'].flatMap(feature => [feature, `min-${feature}`, `max-${feature}`]));\nfunction validateMediaType(node) {\n  const {\n    type: nodeType,\n    value: nodeValue\n  } = node;\n  if (nodeType === 'media-type') {\n    return MEDIA_TYPES.has(nodeValue);\n  } else if (nodeType === 'keyword') {\n    return MEDIA_KEYWORDS.has(nodeValue);\n  } else if (nodeType === 'media-feature') {\n    return MEDIA_FEATURES.has(nodeValue);\n  }\n}\n\n/**\n *\n * @param {string} Media query to validate\n * @returns {boolean}\n *\n * This function performs a basic media query validation\n * to ensure the values passed as part of the 'media' config\n * is HTML safe and does not cause any injection issue\n */\nfunction validateMediaQuery(query) {\n  // The below is needed for consumption with webpack.\n  const mediaParserFn = 'default' in mediaParser ? mediaParser.default : mediaParser;\n  const mediaTree = mediaParserFn(query);\n  const nodeTypes = new Set(['media-type', 'keyword', 'media-feature']);\n  const stack = [mediaTree];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (nodeTypes.has(node.type) && !validateMediaType(node)) {\n      return false;\n    }\n    if (node.nodes) {\n      stack.push(...node.nodes);\n    }\n  }\n  return true;\n}\nconst LOG_LEVELS = ['trace', 'debug', 'info', 'warn', 'error', 'silent'];\nconst defaultLogger = {\n  trace(msg) {\n    console.trace(msg);\n  },\n  debug(msg) {\n    console.debug(msg);\n  },\n  warn(msg) {\n    console.warn(chalk.yellow(msg));\n  },\n  error(msg) {\n    console.error(chalk.bold.red(msg));\n  },\n  info(msg) {\n    console.info(chalk.bold.blue(msg));\n  },\n  silent() {}\n};\nfunction createLogger(logLevel) {\n  const logLevelIdx = LOG_LEVELS.indexOf(logLevel);\n  return LOG_LEVELS.reduce((logger, type, index) => {\n    if (index >= logLevelIdx) {\n      logger[type] = defaultLogger[type];\n    } else {\n      logger[type] = defaultLogger.silent;\n    }\n    return logger;\n  }, {});\n}\nfunction isSubpath(basePath, currentPath) {\n  return !path.relative(basePath, currentPath).startsWith('..');\n}\n\n/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n/**\n * The mechanism to use for lazy-loading stylesheets.\n *\n * Note: <kbd>JS</kbd> indicates a strategy requiring JavaScript (falls back to `<noscript>` unless disabled).\n *\n * - **default:** Move stylesheet links to the end of the document and insert preload meta tags in their place.\n * - **\"body\":** Move all external stylesheet links to the end of the document.\n * - **\"media\":** Load stylesheets asynchronously by adding `media=\"not x\"` and removing once loaded. <kbd>JS</kbd>\n * - **\"swap\":** Convert stylesheet links to preloads that swap to `rel=\"stylesheet\"` once loaded ([details](https://www.filamentgroup.com/lab/load-css-simpler/#the-code)). <kbd>JS</kbd>\n * - **\"swap-high\":** Use `<link rel=\"alternate stylesheet preload\">` and swap to `rel=\"stylesheet\"` once loaded ([details](http://filamentgroup.github.io/loadCSS/test/new-high.html)). <kbd>JS</kbd>\n * - **\"js\":** Inject an asynchronous CSS loader similar to [LoadCSS](https://github.com/filamentgroup/loadCSS) and use it to load stylesheets. <kbd>JS</kbd>\n * - **\"js-lazy\":** Like `\"js\"`, but the stylesheet is disabled until fully loaded.\n * - **false:** Disables adding preload tags.\n * @typedef {(default|'body'|'media'|'swap'|'swap-high'|'js'|'js-lazy')} PreloadStrategy\n * @public\n */\n\n/**\n * Controls which keyframes rules are inlined.\n *\n * - **\"critical\":** _(default)_ inline keyframes rules that are used by the critical CSS.\n * - **\"all\":** Inline all keyframes rules.\n * - **\"none\":** Remove all keyframes rules.\n * @typedef {('critical'|'all'|'none')} KeyframeStrategy\n * @private\n * @property {String} keyframes     Which {@link KeyframeStrategy keyframe strategy} to use (default: `critical`)_\n */\n\n/**\n * Controls log level of the plugin. Specifies the level the logger should use. A logger will\n * not produce output for any log level beneath the specified level. Available levels and order\n * are:\n *\n * - **\"info\"** _(default)_\n * - **\"warn\"**\n * - **\"error\"**\n * - **\"trace\"**\n * - **\"debug\"**\n * - **\"silent\"**\n * @typedef {('info'|'warn'|'error'|'trace'|'debug'|'silent')} LogLevel\n * @public\n */\n\n/**\n * Custom logger interface:\n * @typedef {object} Logger\n * @public\n * @property {function(String)} trace - Prints a trace message\n * @property {function(String)} debug - Prints a debug message\n * @property {function(String)} info - Prints an information message\n * @property {function(String)} warn - Prints a warning message\n * @property {function(String)} error - Prints an error message\n */\n\n/**\n * All optional. Pass them to `new Critters({ ... })`.\n * @public\n * @typedef Options\n * @property {String} path     Base path location of the CSS files _(default: `''`)_\n * @property {String} publicPath     Public path of the CSS resources. This prefix is removed from the href _(default: `''`)_\n * @property {Boolean} external     Inline styles from external stylesheets _(default: `true`)_\n * @property {Number} inlineThreshold Inline external stylesheets smaller than a given size _(default: `0`)_\n * @property {Number} minimumExternalSize If the non-critical external stylesheet would be below this size, just inline it _(default: `0`)_\n * @property {Boolean} pruneSource  Remove inlined rules from the external stylesheet _(default: `false`)_\n * @property {Boolean} mergeStylesheets Merged inlined stylesheets into a single `<style>` tag _(default: `true`)_\n * @property {String[]} additionalStylesheets Glob for matching other stylesheets to be used while looking for critical CSS.\n * @property {String} preload       Which {@link PreloadStrategy preload strategy} to use\n * @property {Boolean} noscriptFallback Add `<noscript>` fallback to JS-based strategies\n * @property {Boolean} inlineFonts  Inline critical font-face rules _(default: `false`)_\n * @property {Boolean} preloadFonts Preloads critical fonts _(default: `true`)_\n * @property {Boolean} fonts        Shorthand for setting `inlineFonts` + `preloadFonts`\n *  - Values:\n *  - `true` to inline critical font-face rules and preload the fonts\n *  - `false` to don't inline any font-face rules and don't preload fonts\n * @property {String} keyframes     Controls which keyframes rules are inlined.\n *  - Values:\n *  - `\"critical\"`: _(default)_ inline keyframes rules used by the critical CSS\n *  - `\"all\"` inline all keyframes rules\n *  - `\"none\"` remove all keyframes rules\n * @property {Boolean} compress     Compress resulting critical CSS _(default: `true`)_\n * @property {String} logLevel      Controls {@link LogLevel log level} of the plugin _(default: `\"info\"`)_\n * @property {object} logger        Provide a custom logger interface {@link Logger logger}\n */\n\nclass Critters {\n  /** @private */\n  constructor(options) {\n    this.options = Object.assign({\n      logLevel: 'info',\n      path: '',\n      publicPath: '',\n      reduceInlineStyles: true,\n      pruneSource: false,\n      additionalStylesheets: [],\n      allowRules: []\n    }, options || {});\n    this.urlFilter = this.options.filter;\n    if (this.urlFilter instanceof RegExp) {\n      this.urlFilter = this.urlFilter.test.bind(this.urlFilter);\n    }\n    this.logger = this.options.logger || createLogger(this.options.logLevel);\n  }\n\n  /**\n   * Read the contents of a file from the specified filesystem or disk\n   */\n  readFile(filename) {\n    const fs = this.fs;\n    return new Promise((resolve, reject) => {\n      const callback = (err, data) => {\n        if (err) reject(err);else resolve(data);\n      };\n      if (fs && fs.readFile) {\n        fs.readFile(filename, callback);\n      } else {\n        readFile(filename, 'utf8', callback);\n      }\n    });\n  }\n\n  /**\n   * Apply critical CSS processing to the html\n   */\n  process(html) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const start = process.hrtime.bigint();\n\n      // Parse the generated HTML in a DOM we can mutate\n      const document = createDocument(html);\n      if (_this.options.additionalStylesheets.length > 0) {\n        _this.embedAdditionalStylesheet(document);\n      }\n\n      // `external:false` skips processing of external sheets\n      if (_this.options.external !== false) {\n        const externalSheets = [].slice.call(document.querySelectorAll('link[rel=\"stylesheet\"]'));\n        yield Promise.all(externalSheets.map(link => _this.embedLinkedStylesheet(link, document)));\n      }\n\n      // go through all the style tags in the document and reduce them to only critical CSS\n      const styles = _this.getAffectedStyleTags(document);\n      yield Promise.all(styles.map(style => _this.processStyle(style, document)));\n      if (_this.options.mergeStylesheets !== false && styles.length !== 0) {\n        yield _this.mergeStylesheets(document);\n      }\n\n      // serialize the document back to HTML and we're done\n      const output = serializeDocument(document);\n      const end = process.hrtime.bigint();\n      _this.logger.info('Time ' + parseFloat(end - start) / 1000000.0);\n      return output;\n    })();\n  }\n\n  /**\n   * Get the style tags that need processing\n   */\n  getAffectedStyleTags(document) {\n    const styles = [].slice.call(document.querySelectorAll('style'));\n\n    // `inline:false` skips processing of inline stylesheets\n    if (this.options.reduceInlineStyles === false) {\n      return styles.filter(style => style.$$external);\n    }\n    return styles;\n  }\n  mergeStylesheets(document) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const styles = _this2.getAffectedStyleTags(document);\n      if (styles.length === 0) {\n        _this2.logger.warn('Merging inline stylesheets into a single <style> tag skipped, no inline stylesheets to merge');\n        return;\n      }\n      const first = styles[0];\n      let sheet = first.textContent;\n      for (let i = 1; i < styles.length; i++) {\n        const node = styles[i];\n        sheet += node.textContent;\n        node.remove();\n      }\n      first.textContent = sheet;\n    })();\n  }\n\n  /**\n   * Given href, find the corresponding CSS asset\n   */\n  getCssAsset(href) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const outputPath = _this3.options.path;\n      const publicPath = _this3.options.publicPath;\n\n      // CHECK - the output path\n      // path on disk (with output.publicPath removed)\n      let normalizedPath = href.replace(/^\\//, '');\n      const pathPrefix = (publicPath || '').replace(/(^\\/|\\/$)/g, '') + '/';\n      if (normalizedPath.startsWith(pathPrefix)) {\n        normalizedPath = normalizedPath.substring(pathPrefix.length).replace(/^\\//, '');\n      }\n\n      // Ignore remote stylesheets\n      if (/^https?:\\/\\//.test(normalizedPath) || href.startsWith('//')) {\n        return undefined;\n      }\n      const filename = path.resolve(outputPath, normalizedPath);\n      // Check if the resolved path is valid\n      if (!isSubpath(outputPath, filename)) {\n        return undefined;\n      }\n      let sheet;\n      try {\n        sheet = yield _this3.readFile(filename);\n      } catch (e) {\n        _this3.logger.warn(`Unable to locate stylesheet: ${filename}`);\n      }\n      return sheet;\n    })();\n  }\n  checkInlineThreshold(link, style, sheet) {\n    if (this.options.inlineThreshold && sheet.length < this.options.inlineThreshold) {\n      const href = style.$$name;\n      style.$$reduce = false;\n      this.logger.info(`\\u001b[32mInlined all of ${href} (${sheet.length} was below the threshold of ${this.options.inlineThreshold})\\u001b[39m`);\n      link.remove();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Inline the stylesheets from options.additionalStylesheets (assuming it passes `options.filter`)\n   */\n  embedAdditionalStylesheet(document) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const styleSheetsIncluded = [];\n      const sources = yield Promise.all(_this4.options.additionalStylesheets.map(cssFile => {\n        if (styleSheetsIncluded.includes(cssFile)) {\n          return;\n        }\n        styleSheetsIncluded.push(cssFile);\n        const style = document.createElement('style');\n        style.$$external = true;\n        return _this4.getCssAsset(cssFile, style).then(sheet => [sheet, style]);\n      }));\n      sources.forEach(([sheet, style]) => {\n        if (!sheet) return;\n        style.textContent = sheet;\n        document.head.appendChild(style);\n      });\n    })();\n  }\n\n  /**\n   * Inline the target stylesheet referred to by a <link rel=\"stylesheet\"> (assuming it passes `options.filter`)\n   */\n  embedLinkedStylesheet(link, document) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const href = link.getAttribute('href');\n      let media = link.getAttribute('media');\n      if (media && !validateMediaQuery(media)) {\n        media = undefined;\n      }\n      const preloadMode = _this5.options.preload;\n\n      // skip filtered resources, or network resources if no filter is provided\n      if (_this5.urlFilter ? _this5.urlFilter(href) : !(href != null && href.endsWith('.css'))) {\n        return Promise.resolve();\n      }\n\n      // the reduced critical CSS gets injected into a new <style> tag\n      const style = document.createElement('style');\n      style.$$external = true;\n      const sheet = yield _this5.getCssAsset(href, style);\n      if (!sheet) {\n        return;\n      }\n      style.textContent = sheet;\n      style.$$name = href;\n      style.$$links = [link];\n      link.parentNode.insertBefore(style, link);\n      if (_this5.checkInlineThreshold(link, style, sheet)) {\n        return;\n      }\n\n      // CSS loader is only injected for the first sheet, then this becomes an empty string\n      let cssLoaderPreamble = \"function $loadcss(u,m,l){(l=document.createElement('link')).rel='stylesheet';l.href=u;document.head.appendChild(l)}\";\n      const lazy = preloadMode === 'js-lazy';\n      if (lazy) {\n        cssLoaderPreamble = cssLoaderPreamble.replace('l.href', \"l.media='print';l.onload=function(){l.media=m};l.href\");\n      }\n\n      // Allow disabling any mutation of the stylesheet link:\n      if (preloadMode === false) return;\n      let noscriptFallback = false;\n      if (preloadMode === 'body') {\n        document.body.appendChild(link);\n      } else {\n        link.setAttribute('rel', 'preload');\n        link.setAttribute('as', 'style');\n        if (preloadMode === 'js' || preloadMode === 'js-lazy') {\n          const script = document.createElement('script');\n          script.setAttribute('data-href', href);\n          script.setAttribute('data-media', media || 'all');\n          const js = `${cssLoaderPreamble}$loadcss(document.currentScript.dataset.href,document.currentScript.dataset.media)`;\n          // script.appendChild(document.createTextNode(js));\n          script.textContent = js;\n          link.parentNode.insertBefore(script, link.nextSibling);\n          style.$$links.push(script);\n          cssLoaderPreamble = '';\n          noscriptFallback = true;\n        } else if (preloadMode === 'media') {\n          // @see https://github.com/filamentgroup/loadCSS/blob/af1106cfe0bf70147e22185afa7ead96c01dec48/src/loadCSS.js#L26\n          link.setAttribute('rel', 'stylesheet');\n          link.removeAttribute('as');\n          link.setAttribute('media', 'print');\n          link.setAttribute('onload', `this.media='${media || 'all'}'`);\n          noscriptFallback = true;\n        } else if (preloadMode === 'swap-high') {\n          // @see http://filamentgroup.github.io/loadCSS/test/new-high.html\n          link.setAttribute('rel', 'alternate stylesheet preload');\n          link.setAttribute('title', 'styles');\n          link.setAttribute('onload', `this.title='';this.rel='stylesheet'`);\n          noscriptFallback = true;\n        } else if (preloadMode === 'swap') {\n          link.setAttribute('onload', \"this.rel='stylesheet'\");\n          noscriptFallback = true;\n        } else {\n          const bodyLink = document.createElement('link');\n          bodyLink.setAttribute('rel', 'stylesheet');\n          if (media) bodyLink.setAttribute('media', media);\n          bodyLink.setAttribute('href', href);\n          document.body.appendChild(bodyLink);\n          style.$$links.push(bodyLink);\n        }\n      }\n      if (_this5.options.noscriptFallback !== false && noscriptFallback &&\n      // Don't parse the URL if it contains </noscript> as it might cause unexpected behavior\n      !href.includes('</noscript>')) {\n        const noscript = document.createElement('noscript');\n        const noscriptLink = document.createElement('link');\n        noscriptLink.setAttribute('rel', 'stylesheet');\n        noscriptLink.setAttribute('href', href);\n        if (media) noscriptLink.setAttribute('media', media);\n        noscript.appendChild(noscriptLink);\n        link.parentNode.insertBefore(noscript, link.nextSibling);\n        style.$$links.push(noscript);\n      }\n    })();\n  }\n\n  /**\n   * Prune the source CSS files\n   */\n  pruneSource(style, before, sheetInverse) {\n    // if external stylesheet would be below minimum size, just inline everything\n    const minSize = this.options.minimumExternalSize;\n    const name = style.$$name;\n    if (minSize && sheetInverse.length < minSize) {\n      this.logger.info(`\\u001b[32mInlined all of ${name} (non-critical external stylesheet would have been ${sheetInverse.length}b, which was below the threshold of ${minSize})\\u001b[39m`);\n      style.textContent = before;\n      // remove any associated external resources/loaders:\n      if (style.$$links) {\n        for (const link of style.$$links) {\n          const parent = link.parentNode;\n          if (parent) parent.removeChild(link);\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse the stylesheet within a <style> element, then reduce it to contain only rules used by the document.\n   */\n  processStyle(style, document) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (style.$$reduce === false) return;\n      const name = style.$$name ? style.$$name.replace(/^\\//, '') : 'inline CSS';\n      const options = _this6.options;\n      const crittersContainer = document.crittersContainer;\n      let keyframesMode = options.keyframes || 'critical';\n      // we also accept a boolean value for options.keyframes\n      if (keyframesMode === true) keyframesMode = 'all';\n      if (keyframesMode === false) keyframesMode = 'none';\n      let sheet = style.textContent;\n\n      // store a reference to the previous serialized stylesheet for reporting stats\n      const before = sheet;\n\n      // Skip empty stylesheets\n      if (!sheet) return;\n      const ast = parseStylesheet(sheet);\n      const astInverse = options.pruneSource ? parseStylesheet(sheet) : null;\n\n      // a string to search for font names (very loose)\n      let criticalFonts = '';\n      const failedSelectors = [];\n      const criticalKeyframeNames = new Set();\n      let includeNext = false;\n      let includeAll = false;\n      let excludeNext = false;\n      let excludeAll = false;\n      const shouldPreloadFonts = options.fonts === true || options.preloadFonts === true;\n      const shouldInlineFonts = options.fonts !== false && options.inlineFonts === true;\n\n      // Walk all CSS rules, marking unused rules with `.$$remove=true` for removal in the second pass.\n      // This first pass is also used to collect font and keyframe usage used in the second pass.\n      walkStyleRules(ast, markOnly(rule => {\n        var _rule$nodes;\n        if (rule.type === 'comment') {\n          // we might want to remove a leading ! on comment blocks\n          // critters can be part of \"legal comments\" which aren't striped on build\n          const crittersComment = rule.text.match(/^(?<!\\! )critters:(.*)/);\n          const command = crittersComment && crittersComment[1];\n          if (command) {\n            switch (command) {\n              case 'include':\n                includeNext = true;\n                break;\n              case 'exclude':\n                excludeNext = true;\n                break;\n              case 'include start':\n                includeAll = true;\n                break;\n              case 'include end':\n                includeAll = false;\n                break;\n              case 'exclude start':\n                excludeAll = true;\n                break;\n              case 'exclude end':\n                excludeAll = false;\n                break;\n            }\n          }\n        }\n        if (rule.type === 'rule') {\n          // Handle comment based markers\n          if (includeNext) {\n            includeNext = false;\n            return true;\n          }\n          if (excludeNext) {\n            excludeNext = false;\n            return false;\n          }\n          if (includeAll) {\n            return true;\n          }\n          if (excludeAll) {\n            return false;\n          }\n\n          // Filter the selector list down to only those match\n          rule.filterSelectors(sel => {\n            // Validate rule with 'allowRules' option\n            const isAllowedRule = options.allowRules.some(exp => {\n              if (exp instanceof RegExp) {\n                return exp.test(sel);\n              }\n              return exp === sel;\n            });\n            if (isAllowedRule) return true;\n\n            // Strip pseudo-elements and pseudo-classes, since we only care that their associated elements exist.\n            // This means any selector for a pseudo-element or having a pseudo-class will be inlined if the rest of the selector matches.\n            if (sel === ':root' || sel === 'html' || sel === 'body' || /^::?(before|after)$/.test(sel)) {\n              return true;\n            }\n            sel = sel.replace(/(?<!\\\\)::?[a-z-]+(?![a-z-(])/gi, '').replace(/::?not\\(\\s*\\)/g, '')\n            // Remove tailing or leading commas from cleaned sub selector `is(.active, :hover)` -> `is(.active)`.\n            .replace(/\\(\\s*,/g, '(').replace(/,\\s*\\)/g, ')').trim();\n            if (!sel) return false;\n            try {\n              return crittersContainer.exists(sel);\n            } catch (e) {\n              failedSelectors.push(sel + ' -> ' + e.message);\n              return false;\n            }\n          });\n\n          // If there are no matched selectors, remove the rule:\n          if (!rule.selector) {\n            return false;\n          }\n          if (rule.nodes) {\n            for (const decl of rule.nodes) {\n              // detect used fonts\n              if (shouldInlineFonts && decl.prop && /\\bfont(-family)?\\b/i.test(decl.prop)) {\n                criticalFonts += ' ' + decl.value;\n              }\n\n              // detect used keyframes\n              if (decl.prop === 'animation' || decl.prop === 'animation-name') {\n                for (const name of decl.value.split(/\\s+/)) {\n                  // @todo: parse animation declarations and extract only the name. for now we'll do a lazy match.\n                  const nameTrimmed = name.trim();\n                  if (nameTrimmed) criticalKeyframeNames.add(nameTrimmed);\n                }\n              }\n            }\n          }\n        }\n\n        // keep font rules, they're handled in the second pass:\n        if (rule.type === 'atrule' && rule.name === 'font-face') return;\n\n        // If there are no remaining rules, remove the whole rule:\n        const rules = (_rule$nodes = rule.nodes) == null ? void 0 : _rule$nodes.filter(rule => !rule.$$remove);\n        return !rules || rules.length !== 0;\n      }));\n      if (failedSelectors.length !== 0) {\n        _this6.logger.warn(`${failedSelectors.length} rules skipped due to selector errors:\\n  ${failedSelectors.join('\\n  ')}`);\n      }\n      const preloadedFonts = new Set();\n      // Second pass, using data picked up from the first\n      walkStyleRulesWithReverseMirror(ast, astInverse, rule => {\n        // remove any rules marked in the first pass\n        if (rule.$$remove === true) return false;\n        applyMarkedSelectors(rule);\n\n        // prune @keyframes rules\n        if (rule.type === 'atrule' && rule.name === 'keyframes') {\n          if (keyframesMode === 'none') return false;\n          if (keyframesMode === 'all') return true;\n          return criticalKeyframeNames.has(rule.params);\n        }\n\n        // prune @font-face rules\n        if (rule.type === 'atrule' && rule.name === 'font-face') {\n          let family, src;\n          for (const decl of rule.nodes) {\n            if (decl.prop === 'src') {\n              // @todo parse this properly and generate multiple preloads with type=\"font/woff2\" etc\n              src = (decl.value.match(/url\\s*\\(\\s*(['\"]?)(.+?)\\1\\s*\\)/) || [])[2];\n            } else if (decl.prop === 'font-family') {\n              family = decl.value;\n            }\n          }\n          if (src && shouldPreloadFonts && !preloadedFonts.has(src)) {\n            preloadedFonts.add(src);\n            const preload = document.createElement('link');\n            preload.setAttribute('rel', 'preload');\n            preload.setAttribute('as', 'font');\n            preload.setAttribute('crossorigin', 'anonymous');\n            preload.setAttribute('href', src.trim());\n            document.head.appendChild(preload);\n          }\n\n          // if we're missing info, if the font is unused, or if critical font inlining is disabled, remove the rule:\n          if (!shouldInlineFonts || !family || !src || !criticalFonts.includes(family)) {\n            return false;\n          }\n        }\n      });\n      sheet = serializeStylesheet(ast, {\n        compress: _this6.options.compress !== false\n      });\n\n      // If all rules were removed, get rid of the style element entirely\n      if (sheet.trim().length === 0) {\n        if (style.parentNode) {\n          style.remove();\n        }\n        return;\n      }\n      let afterText = '';\n      let styleInlinedCompletely = false;\n      if (options.pruneSource) {\n        const sheetInverse = serializeStylesheet(astInverse, {\n          compress: _this6.options.compress !== false\n        });\n        styleInlinedCompletely = _this6.pruneSource(style, before, sheetInverse);\n        if (styleInlinedCompletely) {\n          const percent = sheetInverse.length / before.length * 100;\n          afterText = `, reducing non-inlined size ${percent | 0}% to ${formatSize(sheetInverse.length)}`;\n        }\n      }\n\n      // replace the inline stylesheet with its critical'd counterpart\n      if (!styleInlinedCompletely) {\n        style.textContent = sheet;\n      }\n\n      // output stats\n      const percent = sheet.length / before.length * 100 | 0;\n      _this6.logger.info('\\u001b[32mInlined ' + formatSize(sheet.length) + ' (' + percent + '% of original ' + formatSize(before.length) + ') of ' + name + afterText + '.\\u001b[39m');\n    })();\n  }\n}\nfunction formatSize(size) {\n  if (size <= 0) {\n    return '0 bytes';\n  }\n  const abbreviations = ['bytes', 'kB', 'MB', 'GB'];\n  const index = Math.floor(Math.log(size) / Math.log(1024));\n  const roundedSize = size / Math.pow(1024, index);\n  // bytes don't have a fraction\n  const fractionDigits = index === 0 ? 0 : 2;\n  return `${roundedSize.toFixed(fractionDigits)} ${abbreviations[index]}`;\n}\nexport default Critters;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}