{"ast":null,"code":"'use strict';\n\nlet {\n  isClean,\n  my\n} = require('./symbols');\nlet Declaration = require('./declaration');\nlet Comment = require('./comment');\nlet Node = require('./node');\nlet parse, Rule, AtRule, Root;\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\nfunction markDirtyUp(node) {\n  node[isClean] = false;\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i);\n    }\n  }\n}\nlet Container = /*#__PURE__*/(() => {\n  class Container extends Node {\n    append(...children) {\n      for (let child of children) {\n        let nodes = this.normalize(child, this.last);\n        for (let node of nodes) this.proxyOf.nodes.push(node);\n      }\n      this.markDirty();\n      return this;\n    }\n    cleanRaws(keepBetween) {\n      super.cleanRaws(keepBetween);\n      if (this.nodes) {\n        for (let node of this.nodes) node.cleanRaws(keepBetween);\n      }\n    }\n    each(callback) {\n      if (!this.proxyOf.nodes) return undefined;\n      let iterator = this.getIterator();\n      let index, result;\n      while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n        index = this.indexes[iterator];\n        result = callback(this.proxyOf.nodes[index], index);\n        if (result === false) break;\n        this.indexes[iterator] += 1;\n      }\n      delete this.indexes[iterator];\n      return result;\n    }\n    every(condition) {\n      return this.nodes.every(condition);\n    }\n    getIterator() {\n      if (!this.lastEach) this.lastEach = 0;\n      if (!this.indexes) this.indexes = {};\n      this.lastEach += 1;\n      let iterator = this.lastEach;\n      this.indexes[iterator] = 0;\n      return iterator;\n    }\n    getProxyProcessor() {\n      return {\n        get(node, prop) {\n          if (prop === 'proxyOf') {\n            return node;\n          } else if (!node[prop]) {\n            return node[prop];\n          } else if (prop === 'each' || typeof prop === 'string' && prop.startsWith('walk')) {\n            return (...args) => {\n              return node[prop](...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index);\n                } else {\n                  return i;\n                }\n              }));\n            };\n          } else if (prop === 'every' || prop === 'some') {\n            return cb => {\n              return node[prop]((child, ...other) => cb(child.toProxy(), ...other));\n            };\n          } else if (prop === 'root') {\n            return () => node.root().toProxy();\n          } else if (prop === 'nodes') {\n            return node.nodes.map(i => i.toProxy());\n          } else if (prop === 'first' || prop === 'last') {\n            return node[prop].toProxy();\n          } else {\n            return node[prop];\n          }\n        },\n        set(node, prop, value) {\n          if (node[prop] === value) return true;\n          node[prop] = value;\n          if (prop === 'name' || prop === 'params' || prop === 'selector') {\n            node.markDirty();\n          }\n          return true;\n        }\n      };\n    }\n    index(child) {\n      if (typeof child === 'number') return child;\n      if (child.proxyOf) child = child.proxyOf;\n      return this.proxyOf.nodes.indexOf(child);\n    }\n    insertAfter(exist, add) {\n      let existIndex = this.index(exist);\n      let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n      existIndex = this.index(exist);\n      for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);\n      let index;\n      for (let id in this.indexes) {\n        index = this.indexes[id];\n        if (existIndex < index) {\n          this.indexes[id] = index + nodes.length;\n        }\n      }\n      this.markDirty();\n      return this;\n    }\n    insertBefore(exist, add) {\n      let existIndex = this.index(exist);\n      let type = existIndex === 0 ? 'prepend' : false;\n      let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n      existIndex = this.index(exist);\n      for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);\n      let index;\n      for (let id in this.indexes) {\n        index = this.indexes[id];\n        if (existIndex <= index) {\n          this.indexes[id] = index + nodes.length;\n        }\n      }\n      this.markDirty();\n      return this;\n    }\n    normalize(nodes, sample) {\n      if (typeof nodes === 'string') {\n        nodes = cleanSource(parse(nodes).nodes);\n      } else if (typeof nodes === 'undefined') {\n        nodes = [];\n      } else if (Array.isArray(nodes)) {\n        nodes = nodes.slice(0);\n        for (let i of nodes) {\n          if (i.parent) i.parent.removeChild(i, 'ignore');\n        }\n      } else if (nodes.type === 'root' && this.type !== 'document') {\n        nodes = nodes.nodes.slice(0);\n        for (let i of nodes) {\n          if (i.parent) i.parent.removeChild(i, 'ignore');\n        }\n      } else if (nodes.type) {\n        nodes = [nodes];\n      } else if (nodes.prop) {\n        if (typeof nodes.value === 'undefined') {\n          throw new Error('Value field is missed in node creation');\n        } else if (typeof nodes.value !== 'string') {\n          nodes.value = String(nodes.value);\n        }\n        nodes = [new Declaration(nodes)];\n      } else if (nodes.selector) {\n        nodes = [new Rule(nodes)];\n      } else if (nodes.name) {\n        nodes = [new AtRule(nodes)];\n      } else if (nodes.text) {\n        nodes = [new Comment(nodes)];\n      } else {\n        throw new Error('Unknown node type in node creation');\n      }\n      let processed = nodes.map(i => {\n        /* c8 ignore next */\n        if (!i[my]) Container.rebuild(i);\n        i = i.proxyOf;\n        if (i.parent) i.parent.removeChild(i);\n        if (i[isClean]) markDirtyUp(i);\n        if (typeof i.raws.before === 'undefined') {\n          if (sample && typeof sample.raws.before !== 'undefined') {\n            i.raws.before = sample.raws.before.replace(/\\S/g, '');\n          }\n        }\n        i.parent = this.proxyOf;\n        return i;\n      });\n      return processed;\n    }\n    prepend(...children) {\n      children = children.reverse();\n      for (let child of children) {\n        let nodes = this.normalize(child, this.first, 'prepend').reverse();\n        for (let node of nodes) this.proxyOf.nodes.unshift(node);\n        for (let id in this.indexes) {\n          this.indexes[id] = this.indexes[id] + nodes.length;\n        }\n      }\n      this.markDirty();\n      return this;\n    }\n    push(child) {\n      child.parent = this;\n      this.proxyOf.nodes.push(child);\n      return this;\n    }\n    removeAll() {\n      for (let node of this.proxyOf.nodes) node.parent = undefined;\n      this.proxyOf.nodes = [];\n      this.markDirty();\n      return this;\n    }\n    removeChild(child) {\n      child = this.index(child);\n      this.proxyOf.nodes[child].parent = undefined;\n      this.proxyOf.nodes.splice(child, 1);\n      let index;\n      for (let id in this.indexes) {\n        index = this.indexes[id];\n        if (index >= child) {\n          this.indexes[id] = index - 1;\n        }\n      }\n      this.markDirty();\n      return this;\n    }\n    replaceValues(pattern, opts, callback) {\n      if (!callback) {\n        callback = opts;\n        opts = {};\n      }\n      this.walkDecls(decl => {\n        if (opts.props && !opts.props.includes(decl.prop)) return;\n        if (opts.fast && !decl.value.includes(opts.fast)) return;\n        decl.value = decl.value.replace(pattern, callback);\n      });\n      this.markDirty();\n      return this;\n    }\n    some(condition) {\n      return this.nodes.some(condition);\n    }\n    walk(callback) {\n      return this.each((child, i) => {\n        let result;\n        try {\n          result = callback(child, i);\n        } catch (e) {\n          throw child.addToError(e);\n        }\n        if (result !== false && child.walk) {\n          result = child.walk(callback);\n        }\n        return result;\n      });\n    }\n    walkAtRules(name, callback) {\n      if (!callback) {\n        callback = name;\n        return this.walk((child, i) => {\n          if (child.type === 'atrule') {\n            return callback(child, i);\n          }\n        });\n      }\n      if (name instanceof RegExp) {\n        return this.walk((child, i) => {\n          if (child.type === 'atrule' && name.test(child.name)) {\n            return callback(child, i);\n          }\n        });\n      }\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && child.name === name) {\n          return callback(child, i);\n        }\n      });\n    }\n    walkComments(callback) {\n      return this.walk((child, i) => {\n        if (child.type === 'comment') {\n          return callback(child, i);\n        }\n      });\n    }\n    walkDecls(prop, callback) {\n      if (!callback) {\n        callback = prop;\n        return this.walk((child, i) => {\n          if (child.type === 'decl') {\n            return callback(child, i);\n          }\n        });\n      }\n      if (prop instanceof RegExp) {\n        return this.walk((child, i) => {\n          if (child.type === 'decl' && prop.test(child.prop)) {\n            return callback(child, i);\n          }\n        });\n      }\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && child.prop === prop) {\n          return callback(child, i);\n        }\n      });\n    }\n    walkRules(selector, callback) {\n      if (!callback) {\n        callback = selector;\n        return this.walk((child, i) => {\n          if (child.type === 'rule') {\n            return callback(child, i);\n          }\n        });\n      }\n      if (selector instanceof RegExp) {\n        return this.walk((child, i) => {\n          if (child.type === 'rule' && selector.test(child.selector)) {\n            return callback(child, i);\n          }\n        });\n      }\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && child.selector === selector) {\n          return callback(child, i);\n        }\n      });\n    }\n    get first() {\n      if (!this.proxyOf.nodes) return undefined;\n      return this.proxyOf.nodes[0];\n    }\n    get last() {\n      if (!this.proxyOf.nodes) return undefined;\n      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n    }\n  }\n  Container.registerParse = dependant => {\n    parse = dependant;\n  };\n  Container.registerRule = dependant => {\n    Rule = dependant;\n  };\n  Container.registerAtRule = dependant => {\n    AtRule = dependant;\n  };\n  Container.registerRoot = dependant => {\n    Root = dependant;\n  };\n  return Container;\n})();\nmodule.exports = Container;\nContainer.default = Container;\n\n/* c8 ignore start */\nContainer.rebuild = node => {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype);\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype);\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype);\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype);\n  } else if (node.type === 'root') {\n    Object.setPrototypeOf(node, Root.prototype);\n  }\n  node[my] = true;\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      Container.rebuild(child);\n    });\n  }\n};\n/* c8 ignore stop */","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}